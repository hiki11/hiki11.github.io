<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Houdini基础教程</title>
      <link href="/2025/07/15/Houdini%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2025/07/15/Houdini%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>创建立方体并探讨GEO节点和SOP节点的功能。<br>GEO节点像一个盒子，可以创建多边形并进行移动、旋转、缩放。<br>SOP节点分为加工型和生产型，前者需要入口数据进行处理，后者直接生成数据。<br>布局设置为高效的面板结构，以便查看节点内部信息。<br>节点之间的连线传输数据，源头节点的变化会实时影响下游节点。<br>不同颜色的按钮具有不同功能，如显示、透显、冻结和跳过节点。<br>连线操作简单，支持剪断、删除和自动布局。<br>模型显示设置可改变视图布局和显示模式。</p><p>sop节点的一个按钮的功能：<br>蓝色的按钮呢我们之前讲过了,他是负责显示这个节点的内容<br>紫色的按钮它的意思就是透显,表示虽然我被隐藏了,但是我可以去透显出我的一个轮廓出来,方便我们进行观察<br>酱红色的标签叫做lock,它就是一个冻结的意思,当我们去切断这个加工型的节点的时候呢,它内部的数据就会全部不见对吧,那这个当我们去冻结他的数据之后,然后我把连线给切断,我们发现诶他的数据还在对吧,相当于说他把这份数据给冻结给保留下来了,不会受到这些传送的影响<br>黄色的按钮叫by pass,它的意思就是说跳过这个节点,它两头的两个节点呢会直接跳过它诶进行传输</p><p>按住键盘的shift加S诶,我可以改变我连线的形态,然后我按住shift加L呢,可以去让胡迪尼帮我去自动布局我的节点</p><p>b键切换视图</p><p>使用group节点选择特定点并创建选集。<br>通过bounding regions自定义选择区域。<br>attricreate创建属性并为选中的点赋值。<br>使用softpeak节点沿法线方向移动点。<br>visualattri可视化属性以便观察变化。<br>atrriblur添加高斯模糊效果以实现细腻过渡。<br>atrriremap使用重映射节点调整属性值。<br>添加mountain节点模拟随机噪波。<br>使用color节点为模型添加渐变色。<br>subdivide以平滑模型，最终形成面包圈。</p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Houdini </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>illustrator 笔记</title>
      <link href="/2025/05/24/illustrator%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/05/24/illustrator%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>选择文件新建，创建A4画板，适合练习和临摹。</p><p>多边形的边数可通过方向键增减，心形的角度也可调整。</p><p>白色可以表示没有颜色或是实际的颜色，具体取决于印刷情况。</p><p>可以通过颜色面板选择配好的颜色，适合用于印刷。<br><img src="/../images/post/illustrator%E7%AC%94%E8%AE%B0/1748054835496.png" alt="1748054835496"></p><p>使用智能参考线可以提高绘图的精准度。(视图或Ctrl+U)<br>开启网格和对齐网格可以帮助更好地控制绘图的自由度和约束。<br>网格间隔和分隔线的设置可以在首选项中调整，以适应设计需求。</p><p>参考线网格线是10，次分隔线是10。</p><p>使用Ctrl+D重复上一步操作。创建新图层的快捷键是Ctrl+L</p><p>使用剪刀工具裁剪不到想要的点，以及没有路径、交点提示，是因为开启了对齐网格。</p><p>连接两条线的方法：用直接选择工具（快捷键A），选择两条线，然后快捷键连接两条线<br>连接两个线的快捷键：Ctrl+J </p><p>判断两条线生死否连接：通过移动连接的锚点观察两条线条是否一起动。</p><p>复制线条时按住alt键，可以通过键盘方向键来调整复制。</p><p>连接三根线的交点时，需移走一根线以便连接。</p><p>使用吸管工具可以吸取颜色和属性，确保风格一致。</p><p>新版本CC可以把尖角改成圆角，使用直接选择工具选择锚点，选择X往后拉。调整角度的前提是必须是尖角。</p><p>只有矩形可以更改圆角，用钢笔画的矩形无法更改圆角。</p><p>批量修改多个矩形圆角最大的方法：创建一个正方形，然后一起选中，把正方形圆角拉到最大。这种方法也可以一次修改矩形的特定几个圆角。</p><p>旋转&#x2F;镜像工具：旋转（R），镜像（O）。alt确定旋转&#x2F;镜像中心。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> illustrator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影视声音设计笔记</title>
      <link href="/2025/05/22/%E5%BD%B1%E8%A7%86%E5%A3%B0%E9%9F%B3%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/05/22/%E5%BD%B1%E8%A7%86%E5%A3%B0%E9%9F%B3%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<!-- # 音频笔记 --><h2 id="一、音效设计"><a href="#一、音效设计" class="headerlink" title="一、音效设计"></a>一、音效设计</h2><h3 id="1-功能型音效"><a href="#1-功能型音效" class="headerlink" title="1. 功能型音效"></a>1. 功能型音效</h3><ul><li><p><strong>上升（Risers）</strong></p><p>制造悬念和期待，常伴随骤降效果，用于引入新章节&#x2F;段落</p></li><li><p><strong>过场音效</strong></p><p>作用：加速画面移动，增强剪辑流畅度</p><p>常见类型：</p><ul><li>呼呼声（whoosh）</li><li>闪回（set backs）</li><li>打击声（Hits）</li></ul></li></ul><h3 id="2-环境氛围"><a href="#2-环境氛围" class="headerlink" title="2. 环境氛围"></a>2. 环境氛围</h3><ul><li><p><strong>低音&amp;氛围（Drones&amp;Atmospheres）</strong></p><p>增加画面深度，传递情感情绪</p></li><li><p><strong>环境音效</strong></p><p>风&#x2F;树林&#x2F;沿海等自然声效，扩展影片空间感</p></li></ul><h3 id="3-时间处理"><a href="#3-时间处理" class="headerlink" title="3. 时间处理"></a>3. 时间处理</h3><ul><li><p><strong>慢动作音效</strong></p><p>强化时间放缓效果</p></li><li><p><strong>时光瞬移（Time-lapse）</strong></p><p>表现时间流逝与加速</p></li></ul><p>参考：<br><a href="https://www.bilibili.com/video/BV1PZ4y1X7Fa/?spm_id_from=333.999.0.0&vd_source=ccf90130d80396981859cd525be711f0">【搬运】音效设计：如何创造身临其境的感觉</a></p><h2 id="二、音乐应用指南"><a href="#二、音乐应用指南" class="headerlink" title="二、音乐应用指南"></a>二、音乐应用指南</h2><h3 id="按音乐类型分类"><a href="#按音乐类型分类" class="headerlink" title="按音乐类型分类"></a>按音乐类型分类</h3><table><thead><tr><th>类型</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>EDM电音</td><td>强节奏电子音乐</td><td>潮流视频&#x2F;快剪</td></tr><tr><td>Film Score</td><td>电影配乐风格</td><td>宣传片&#x2F;运动合集</td></tr><tr><td>Ambient</td><td>环境氛围音乐</td><td>空镜&#x2F;氛围片段</td></tr><tr><td>Lofi Hiphop</td><td>低保真慵懒质感</td><td>情绪类短片</td></tr><tr><td>北欧后摇</td><td>前奏沉稳+高潮明显</td><td>人文纪录片&#x2F;宣传片</td></tr></tbody></table><h3 id="特殊风格应用"><a href="#特殊风格应用" class="headerlink" title="特殊风格应用"></a>特殊风格应用</h3><ul><li><strong>HIP HOP</strong>：极限运动&#x2F;说唱合集</li><li><strong>Future Bass</strong>：酷炫旅拍&#x2F;时尚剪辑</li><li><strong>Swing</strong>：复古港风&#x2F;小资情调</li><li><strong>Jazz</strong>：性感狂野场景</li><li><strong>乡村音乐</strong>：亲切感叙事</li></ul><p>参考：<br><a href="https://www.bilibili.com/video/BV1LW4y1x7ka/?vd_source=ccf90130d80396981859cd525be711f0">B站史上最全的音乐搜索分类 看完再找不到合适的音乐 我给你找！！！</a></p><h2 id="三、混音基础"><a href="#三、混音基础" class="headerlink" title="三、混音基础"></a>三、混音基础</h2><h3 id="音效分层"><a href="#音效分层" class="headerlink" title="音效分层"></a>音效分层</h3><ol><li><strong>同期声</strong>：拍摄时现场录制</li><li><strong>拟音</strong>：后期添加的拟真音效（拍照声&#x2F;脚步声等）</li><li><strong>特效音</strong>：<ul><li>转场音（唰声）</li><li>Rise&amp;Down</li><li>撞击声</li></ul></li></ol><h3 id="核心效果器"><a href="#核心效果器" class="headerlink" title="核心效果器"></a>核心效果器</h3><ol><li><strong>EQ均衡器</strong><ul><li>噪声区（0-100Hz）需压制</li><li>人声增强区（200-600Hz）【200-300Hz：男女声低音最强频段】</li><li>齿音控制区（2-4kHz）</li></ul></li><li><strong>滤波器</strong><ul><li>低通：削弱高频（电话音效）</li><li>高通：削弱低频（去除底噪）</li></ul></li><li><strong>时间效果</strong><ul><li>变速处理：加速&#x2F;减速&#x2F;倒放</li><li>延迟效果：空间感塑造</li><li>混响组合：模拟不同环境声场</li></ul></li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>音量平衡 → 2. 降噪处理 → 3. EQ调节 → 4. 效果器组合</li></ol><p>参考：<br><a href="https://www.bilibili.com/video/BV1hV411z72R/?spm_id_from=333.337.search-card.all.click&vd_source=ccf90130d80396981859cd525be711f0">【啥是剪辑进阶篇】第六讲 剪辑软件混音基础（音效种类+PR音频效果器）</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音频 </tag>
            
            <tag> 剪辑 </tag>
            
            <tag> 音乐 </tag>
            
            <tag> 音效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《做C4D Cinema 4D电商视觉设计教程》笔记</title>
      <link href="/2025/05/20/%E3%80%8A%E5%81%9AC4D%20Cinema%204D%E7%94%B5%E5%95%86%E8%A7%86%E8%A7%89%E8%AE%BE%E8%AE%A1%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/05/20/%E3%80%8A%E5%81%9AC4D%20Cinema%204D%E7%94%B5%E5%95%86%E8%A7%86%E8%A7%89%E8%AE%BE%E8%AE%A1%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-C4D基础知识"><a href="#第1章-C4D基础知识" class="headerlink" title="第1章 C4D基础知识"></a>第1章 C4D基础知识</h2><p><strong>显示模式</strong></p><p>• 光影着色（线条）模式</p><p>  快捷键：<code>N</code> → <code>B</code>，显示模型分段线与光影效果</p><p>• 快速着色模式</p><p>  去除光源影响的显示模式</p><p><strong>变形器问题解决</strong></p><ol><li>检查模型分段线使用”光影着色（线条）”模式确认模型分段是否足够</li><li>调整变形器边界框确保变形器完全包裹模型（可手动调整尺寸）</li><li>检查变形器方向<br>在属性面板中调试方向参数</li></ol><p><strong>常用快捷键</strong><br>• <code>Shift+Alt+E</code>：打开时间线窗口</p><p>• <code>Alt+A</code>：显示&#x2F;隐藏所有对象</p><hr><h2 id="第2章-电商KV-Banner专项突破"><a href="#第2章-电商KV-Banner专项突破" class="headerlink" title="第2章 电商KV&#x2F;Banner专项突破"></a>第2章 电商KV&#x2F;Banner专项突破</h2><p><strong>立体字制作</strong></p><ol><li>挤压对象设置勾选“层级”复选框（模拟AI立体效果）</li><li>合并对象<br>使用“连接对象+删除”命令整合模型</li></ol><p><strong>样条绘制技巧</strong></p><p>• 样条画笔工具</p><p>  模拟Photoshop钢笔工具绘制。绘制字形效果不佳时，可手绘草稿并扫描为图片，拖入C4D视图作为背景参考。</p><p>• 背景参考图</p><p>  拖入图片至视图，按 <code>Shift+V</code>调整透明度（半透明参考不影响渲染）</p><hr><h2 id="第3章-常见元素建模和渲染技巧"><a href="#第3章-常见元素建模和渲染技巧" class="headerlink" title="第3章 常见元素建模和渲染技巧"></a>第3章 常见元素建模和渲染技巧</h2><p><strong>细分曲面原理</strong></p><p>• 作用：通过增加低模的细分数量（“编辑器细分”和“渲染器细分”参数），使表面平滑</p><p>• 应用：将模型拖入细分曲面子级，调整细分级别</p><p><strong>礼盒盒体建模</strong></p><ol><li>调整平滑着色角度减小“平滑着色角度”（如10°），使棱角更分明</li><li>晶格工具<br>生成网格结构，勾选“隐藏新的边”避免冗余线</li></ol><p><strong>波浪形建模（番茄酱）</strong><br>• 公式对象参数</p><p>  设置 <code>Tmax=40</code>，<code>采样=30</code>，勾选“立方插值”生成波浪线</p><hr><h2 id="第4章-场景搭建技巧"><a href="#第4章-场景搭建技巧" class="headerlink" title="第4章 场景搭建技巧"></a>第4章 场景搭建技巧</h2><p><strong>晶格与扭曲对象</strong></p><ol><li>晶格变形添加扭曲对象至晶格子级，点击“匹配到父级”</li><li>调整旋转角度<br>设置“角度”参数（如26°）生成旋转效果</li></ol><p><strong>无缝背景制作</strong></p><ol><li>地面合成背景勾选“合成背景”复选框（地面接收阴影）</li><li>天空环境<br>设置天空为“可见环境”类型，仅作为背景不影响反射</li></ol><p><strong>灯光与摄像机</strong><br>• 灯光控制</p><p>  • 强度、面积、距离共同影响明暗</p><p>  • 大面积灯光→影子虚；小面积灯光→影子实</p><p>• 摄像机参数</p><p>  • 焦距数值：越大包含内容越多，四周形变越严重</p><p>  • 景深效果：光圈数值越小，背景虚化越强</p><p><strong>水面涟漪效果</strong><br>• 公式对象参数</p><p>  调整 <code>d(u,v,x,y,z,t)</code>的最后一项（如0.08）控制波纹幅度</p><hr><h2 id="第6章-电商主图建模技巧"><a href="#第6章-电商主图建模技巧" class="headerlink" title="第6章 电商主图建模技巧"></a>第6章 电商主图建模技巧</h2><p><strong>多边形建模原则</strong></p><ol><li>避免极点优先使用四边形，极点易导致曲面变形</li><li>细分曲面应用<br>低模+细分曲面生成高模（平滑表面）</li></ol><p><strong>保护线创建方法</strong><br>• 通过切线、倒角或手动布线控制模型转折结构</p><p><strong>扇叶建模步骤</strong></p><ol><li>平面对象转可编辑按 <code>C</code>键转换，使用多边形画笔工具扩展四边形面</li><li>Ctrl+拖拽<br>按住 <code>Ctrl</code>拖拽边线生成新面，调整点位置控制形状</li></ol><hr><h2 id="第7章-进阶渲染技巧"><a href="#第7章-进阶渲染技巧" class="headerlink" title="第7章 进阶渲染技巧"></a>第7章 进阶渲染技巧</h2><p><strong>渲染器对比</strong><br>• 标准渲染器</p><p>  CPU渲染，适合简单场景（纯色、快速出图）<br>• 物理渲染器</p><p>  模拟真实物理效果（金属反射更佳），需调整采样器（如“递增”模式）</p><p><strong>材质与反光板</strong></p><ol><li>强反射材质粗糙度归零，赋予Logo部分</li><li>反光板设置<br>创建平面贴近模型，赋予发光材质（强度0.6）</li></ol><p><strong>法线贴图生成</strong><br>• 在Photoshop中通过“生成法线图”命令创建</p><hr><h2 id="第8章-设计方法论"><a href="#第8章-设计方法论" class="headerlink" title="第8章 设计方法论"></a>第8章 设计方法论</h2><p><strong>构图法则</strong></p><ol><li>三分法主体置于画面1&#x2F;3位置（黄金分割）</li><li>平衡法对称或轴向平衡（上下&#x2F;左右&#x2F;对角线）</li><li>三角线法<br>三元素构成稳定三角形（正三角、倒三角）</li></ol><p><strong>配色逻辑</strong><br>• 顺色法</p><p>  同类色（色环30°内）或近似色（60-90°），和谐统一<br>• 撞色法</p><p>  对比色（120-180°）或互补色（180°），视觉冲击强</p><p><strong>画面焦点强化</strong></p><ol><li>放大主体直接提升占比吸引目光</li><li>高对比色局部使用亮色或互补色</li><li>光影聚焦<br>暗背景+聚光突出主体</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C4D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C4D </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 电商 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解灯光</title>
      <link href="/2025/04/09/%E7%90%86%E8%A7%A3%E7%81%AF%E5%85%89/"/>
      <url>/2025/04/09/%E7%90%86%E8%A7%A3%E7%81%AF%E5%85%89/</url>
      
        <content type="html"><![CDATA[<p>5、可读性<br>可读性实际上就是充足的照明和物体的分离。<br>充足的照明增加可读性<br><img src="/../images/post/%E7%90%86%E8%A7%A3%E7%81%AF%E5%85%89/1744215334735.png" alt="1744215334735"></p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灯光 </tag>
            
            <tag> 影视 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS2 Dust2 道具速查</title>
      <link href="/2025/03/21/CS2-Dust2-%E9%81%93%E5%85%B7/"/>
      <url>/2025/03/21/CS2-Dust2-%E9%81%93%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="A大道具"><a href="#A大道具" class="headerlink" title="A大道具"></a>A大道具</h2><h3 id="CT方反清闪"><a href="#CT方反清闪" class="headerlink" title="CT方反清闪"></a>CT方反清闪</h3><p>靠近墙角，双键出手<br><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1748670094520.jpg" alt="1748670094520"></p><hr><h2 id="中路道具"><a href="#中路道具" class="headerlink" title="中路道具"></a>中路道具</h2><h3 id="T方中门闪"><a href="#T方中门闪" class="headerlink" title="T方中门闪"></a>T方中门闪</h3><p>瞄准电线交汇处，左拉到下方UI贴着箱子绳索【大概就行】，双键出手</p><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742477966970.jpg" alt="1742477966970"></p><p><strong>中门满封烟</strong></p><p>贴着B1拱门左边墙，瞄准此处斑点直接丢</p><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742478130656.jpg" alt="1742478130656"></p><h3 id="中门凹槽火"><a href="#中门凹槽火" class="headerlink" title="中门凹槽火"></a>中门凹槽火</h3><p>【优点】烧不到出中门的人，丢完可以接个闪直接出</p><p>站着靠住B1右边角落，瞄准斑块此处。</p><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742478565463.jpg" alt="1742478565463"></p><p>蹲下双键出手。同时可以切闪，再丢一个瞬闪。</p><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742478682783.jpg" alt="1742478682783"></p><h3 id="警家烟"><a href="#警家烟" class="headerlink" title="警家烟"></a>警家烟</h3><p>蹲着描点跳投</p><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742476949463.png" alt="1742476949463"><strong>中门炸烟雷</strong></p><p>蹲着描点跳投</p><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742477053395.jpg" alt="1742477053395"></p><h3 id="小道瀑布烟"><a href="#小道瀑布烟" class="headerlink" title="小道瀑布烟"></a>小道瀑布烟</h3><div class="tabs" id="容器名称（可省略）"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="容器名称（可省略）-1">站位</button><button type="button" class="tab " data-href="容器名称（可省略）-2">描点</button></ul><div class="tab-contents"><div class="tab-item-content active" id="容器名称（可省略）-1"><p>蹲下瞄准黑点</p><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742477148123.jpg" alt="1742477148123"></p></div><div class="tab-item-content" id="容器名称（可省略）-2"><p>瞄准窗户此处直接扔<img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742477157492.jpg" alt="1742477157492"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="X箱烟"><a href="#X箱烟" class="headerlink" title="X箱烟"></a>X箱烟</h3><p>贴着墙，让黄色墙贴到第二个窗户右侧，瞄准尖尖，跑几步扔<img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742477784896.jpg" alt="1742477784896"></p><h3 id="B1清点火"><a href="#B1清点火" class="headerlink" title="B1清点火"></a>B1清点火</h3><p>瞄准斑点，跑几步扔</p><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742477864299.jpg" alt="1742477864299"></p><hr><h2 id="B点道具"><a href="#B点道具" class="headerlink" title="B点道具"></a>B点道具</h2><h3 id="B1清小道闪"><a href="#B1清小道闪" class="headerlink" title="B1清小道闪"></a>B1清小道闪</h3><p>双键直接扔</p><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742477305975.jpg" alt="1742477305975"></p><h3 id="B门闪"><a href="#B门闪" class="headerlink" title="B门闪"></a>B门闪</h3><p>抵住箱子，双键出手</p><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742477366073.jpg" alt="1742477366073"></p><h3 id="B洞过点烟"><a href="#B洞过点烟" class="headerlink" title="B洞过点烟"></a>B洞过点烟</h3><div class="tabs" id="容器名称（可省略）"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="容器名称（可省略）-1">站点</button><button type="button" class="tab " data-href="容器名称（可省略）-2">描点</button></ul><div class="tab-contents"><div class="tab-item-content active" id="容器名称（可省略）-1"><p>靠住杆子中间</p><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742477680134.jpg" alt="1742477680134"></p></div><div class="tab-item-content" id="容器名称（可省略）-2"><p>瞄准此处，跑到墙顶边缘跳投</p><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1742477691164.jpg" alt="1742477691164"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="CT-B点回防闪"><a href="#CT-B点回防闪" class="headerlink" title="CT-B点回防闪"></a>CT-B点回防闪</h3><p><img src="/../images/post/CS2-Dust2-%E9%81%93%E5%85%B7/1752923573810.jpg" alt="1752923573810"></p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剪辑笔记</title>
      <link href="/2023/12/29/%E5%89%AA%E8%BE%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/29/%E5%89%AA%E8%BE%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="剪辑笔记"><a href="#剪辑笔记" class="headerlink" title="剪辑笔记"></a>剪辑笔记</h1><p>视听语言课 色彩构成课 构图课</p><h2 id="剪辑思维"><a href="#剪辑思维" class="headerlink" title="剪辑思维"></a>剪辑思维</h2><p>剪：确定一个镜头保留的位置和时长</p><p>辑：将保留精选后的镜头排列组合的过程</p><h3 id="剪辑四大原理"><a href="#剪辑四大原理" class="headerlink" title="剪辑四大原理"></a>剪辑四大原理</h3><p><img src="/../images/post/%E5%89%AA%E8%BE%91%E7%AC%94%E8%AE%B0/1703830155089.png" alt="1703830155089"></p><p><strong>信息</strong>：画面中所有你能看到的一切事物</p><p>（一系列视听元素和效果等）</p><p> <strong>剪辑的实质</strong> ：信息收集与处理组合的过程</p><p> <strong>大景别</strong> ：保留较长时间，具有表现环境的宏伟或展现人物渺小孤独的环境烘托作用</p><p><img src="/../images/post/%E5%89%AA%E8%BE%91%E7%AC%94%E8%AE%B0/1703830168214.png" alt="1703830168214"></p><p><img src="/../images/post/%E5%89%AA%E8%BE%91%E7%AC%94%E8%AE%B0/1703830173749.png" alt="1703830173749"></p><p>在推镜头的过程中，画面的信息不断被裁切减少，越来越单一，剩余的信息都在被逐渐放大</p><p><img src="/../images/post/%E5%89%AA%E8%BE%91%E7%AC%94%E8%AE%B0/1703830178795.png" alt="1703830178795"></p><p> <strong>拉镜头：</strong> 疏远 背叛 揭示</p><p> <strong>暖色调：</strong> 温馨氛围</p><p> <strong>顺光：</strong> 美好 爱情</p><p> <strong>底光：</strong> 恐怖 反派</p><p> <strong>希区柯克镜头：</strong> 内心波动</p><p> <strong>格式塔理论的衍伸：</strong> 蒙太奇，组合信息带来更多信息的梳理方式</p><p> <strong>情绪容器</strong> <strong>（UP自创）：情绪可堆积的范围，即观众能够承受持续堆积的同类情绪的程度</strong></p><ol><li>一直保持相同情绪不做转变，超出观众心理预期，会失去吸引力和兴趣</li><li>在符合观众预期的节点转变情绪，正确但不够出彩</li><li>在情绪不溢出的范围内，突破观众心理预期，提升吸引力和兴趣</li></ol><p>不同类型影片的容器容量不同</p><p> <strong>场景：</strong> <strong>每一个场景都是一个完整的信息处理段落</strong></p><p>粗剪：选取镜头 定场景 定逻辑</p><p>精剪：精细调整，以场景为单位剪辑</p><ol><li>在单个场景中，第一目标是要找到这个场景的主镜头，主镜头能够体现当前环境、人物状态、位置、时间等因素的客观性与整体性（非主观视点、信息充足）</li><li>然后将同一场景的镜头或者跟该场景有关联的镜头，通过剪辑手法穿插在主镜头的周围</li><li>单个场景中不要选择多个主镜头</li><li>只有在平行或交叉剪辑这类设计多个场景的剪辑中才能使用多个主镜头交替</li></ol><p>转场：一个场景到下一个场景</p><p>转场原理：前后场景信息量较小、信息相似、信息连贯，三者其一就可以完成转场</p><p> <strong>动作与反应</strong> <strong>：动作镜头通常和反应镜头相接，反应镜头可以是动作发出者也可以是动作接收者</strong></p><p>如果动作有特殊含义，可以不施加反应镜头，对动作施加一个悬念，但如不是刻意设计的结尾，一定要在之后的场景中将这个动作悬念的结果交代出来</p><h2 id="如何决定镜头时长"><a href="#如何决定镜头时长" class="headerlink" title="如何决定镜头时长"></a>如何决定镜头时长</h2><p><strong>总结：情绪&gt;动作&gt;特殊剪辑手段&gt;景别</strong></p><p>影响镜头长度的因素有情绪、动作、特殊剪辑手段和景别优先级。</p><p>景别：并非大景别就一定要留长，小景别就留短，而是看画面信息量。观众获取镜头信息的难易程度影响镜头时长。</p><p>特殊剪辑手段：快切、卡点和匹配剪辑等技巧应用。主要是看流畅度来决定镜头时长，也就是凭感觉。以手法来表现含义。</p><p>动作：动作拆分（起手→顶点→收手）。可以利用过程来接两个动作，如动作A（起手）到动作B（顶点→收手）。</p><p>情绪：有时候镜头时长会影响情绪（比如镜头留长来加强悲伤）。在剪辑时要注重情绪的表达和内容的抒发，而不是仅注重形式。影片的核心是内容，是情绪的代入和抒发。</p><h2 id="背景音乐和人声的响度"><a href="#背景音乐和人声的响度" class="headerlink" title="背景音乐和人声的响度"></a>背景音乐和人声的响度</h2><p>人声响度：-18~-6db，大声的地方最好不要超过-3db</p><p>背景音乐响度：人声响度 - 20~30db</p><p>背景音乐加上低通效果器。因为人声主要在中高频，而音乐会和人声重叠。</p><p>低通滤波器还可以用于模拟人声在水下效果，或是用于慢动作的音效。</p><p>Pr调整冲突的方法：<a href="https://www.bilibili.com/video/BV13t4y1X7ge/?vd_source=ccf90130d80396981859cd525be711f0">https://www.bilibili.com/video/BV13t4y1X7ge/?vd_source=ccf90130d80396981859cd525be711f0</a></p><h2 id="人物对话场景技巧"><a href="#人物对话场景技巧" class="headerlink" title="人物对话场景技巧"></a>人物对话场景技巧</h2><p>两人对话的两个场景，在拼接时可以将后一个场景对话提前一点。未见其人，先闻其声。可以营造出观众在听两人对话的感觉（听到另一人的声音，扭头转向另一人）。</p><p><a href="https://www.bilibili.com/video/BV1mR4y1E7zy/?spm_id_from=333.788&vd_source=ccf90130d80396981859cd525be711f0">参考视频</a></p><h2 id="剪辑时间序列规划"><a href="#剪辑时间序列规划" class="headerlink" title="剪辑时间序列规划"></a>剪辑时间序列规划</h2><p>总结：<br>视频层：主要编辑层、效果层、调色层和字幕层。<br>音频层：单声道对话层、单声道音效层、立体声音效层和混音层</p><p>视频层：</p><ul><li>主要编辑层：编辑大部分的视觉素材，所有的镜头都添加于此。此外还包括一些简单的视频效果，比如缩放调整、色键、擦除、渐隐、溶解。4条轨道。</li><li>效果层：外部图像或者视觉特效，包括绿屏、遮罩和数字符号等。1条轨道。</li><li>调色层：临时的颜色校正和调整，将使用此轨道对其下所有视频轨进行调整（调整图层）。1条轨道。</li><li>遮幅层：添加黑色遮幅</li><li>字幕层：添加字幕，或者纪录片注解等。1条轨道。</li><li>注释层：注释关于视觉效果的信息。用来辅助标注视频信息，方便追踪来源。<br>音频层：</li><li>单声道对话层：对话都是单声道录制的，以消除立体声录制可能出现的问题。4条轨道。</li><li>单声道音效层：放置单声道的简单音效。4条轨道。</li><li>立体声音效层：放置立体声效和立体声环境音。4条轨道。</li><li>音乐层：放置立体声音乐。2条轨道。</li><li>混音层：3条轨道，分别对应上述的对话层、音效层和音乐层。如果是团队协作，声效部门做出来的混音就放在这，然后屏蔽对应的音频层。</li></ul><p><a href="https://www.bilibili.com/video/BV1bF411z7BV/?spm_id_from=333.788&vd_source=ccf90130d80396981859cd525be711f0">参考视频</a></p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剪辑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>After Effects 相机内部</title>
      <link href="/2023/12/28/After-Effects-%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/"/>
      <url>/2023/12/28/After-Effects-%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>以下均为机翻</strong><br><a href="https://www.provideocoalition.com/inside-the-after-effects-camera/">原文链接</a></p><blockquote><p><img src="https://www.provideocoalition.com/wp-content/uploads/Chris_Zwar-2-48x48.jpg" alt="个人资料图片"><a href="https://www.provideocoalition.com/author/czwar/">克里斯·兹瓦尔</a><br>2014 年 5 月 19 日</p></blockquote><p>After Effects 最强大的功能之一是能够使用 3D 图层和虚拟相机。虽然将相机添加到合成中并对其进行动画处理很简单，但通过对相机工作原理以及各种设置含义的基本技术了解，可以对最终结果进行更好的创意控制。</p><p>本文的目的是尝试弥合 After Effects 相机的创意和技术方面之间的一些差距。对于那些编写使用相机设置的脚本和表达式的人来说，它可能最有用。如果你想<a href="https://www.provideocoalition.com/czwar/story/inside-the-after-effects-camera/P6">跳到最后</a>，那么最后一页上有一些复制和粘贴表达式。</p><p>当您在任何图形应用程序中使用虚拟相机时（不仅仅是 After Effects），理解所使用的略有不同的术语可能会令人困惑。不幸的是，在某些情况下，不同的应用程序对同一事物使用不同的名称，因此首先我们将介绍相机的基本原理，然后我们将讨论它们应用于 After Effects 的方式。</p><h4 id="背景-–-真实相机-101"><a href="#背景-–-真实相机-101" class="headerlink" title="背景 – 真实相机 101"></a>背景 – 真实相机 101</h4><p>在最基本的层面上，相机是将图像聚焦到表面上的镜头。最简单的相机类型是“<a href="https://en.wikipedia.org/wiki/Camera_obscura">暗箱</a>”，它基本上是一个有孔的盒子。有一些著名的暗箱向公众开放的<a href="https://en.wikipedia.org/wiki/Camera_Obscura_(San_Francisco,_California)">例子</a>，最近荷兰艺术家维米尔使用暗箱来创作画作的理论受到了<a href="http://www.sonyclassics.com/timsvermeer/">很多关注。</a></p><p>暗箱无法对其产生的图像进行任何控制，因此现代相机发明的最大进步之一就是引入了镜头来取代小孔。</p><p>镜头是我们对相机产生的图像最基本的控制。镜头精确控制整个场景的“捕捉”或记录的程度。选择镜头并描述给定镜头的属性是使用相机时最重要的部分之一。</p><p>本文的大部分内容是关于测量和控制相机镜头的，但是虽然列出所涉及的数学很容易，但解释镜头在使用相机时所具有的创造性重要性 <em>要困难得多。</em> 有许多资源可以解释<a href="https://www.google.com.au/search?q=camera+focal+length+examples&sa=X&tbm=isch&tbo=u&source=univ&ei=Vnd5U9-PI4TQkgX3koHYCA&ved=0CDMQsAQ&biw=1620&bih=1025">不同镜头的性能</a>，并且专业摄影师花费大量时间讨论和比较可能花费数万美元的现实世界镜头。</p><p>维基百科是一个很好的概述<a href="https://en.wikipedia.org/wiki/Focal_Length#In_photography">不同镜头对图像效果的</a>地方，并且还有许多其他类似的资源专注于创意方面。</p><p>所以在我们深入研究之前，请相信我——镜头很重要。</p><h4 id="理解——和误解——透视透视法"><a href="#理解——和误解——透视透视法" class="headerlink" title="理解——和误解——透视透视法"></a>理解——和误解——透视透视法</h4><p>选择特定镜头有很多创造性的原因，但人们经常教授的关于镜头的一件事略有错误。</p><p>几乎在所有摄影教科书中，您都会找到一些关于长焦镜头如何压缩背景的陈述，或者广角镜头如何增加物体之间的视距离，或者类似的效果。无论该声明的措辞如何，通常都认为您选择的镜头将决定物体出现在一起的距离。</p><p>这并不完全正确。这也不是完全错误的，但镜头只是等式的一半。在制作相机动画时，理解这种误解非常重要。</p><p>如果用广角镜头和长焦镜头拍摄同一张照片，它们看起来确实会有所不同。正如教科书所说，长焦版本看起来会“更平坦”，并且物体看起来比广角版本中的距离更近。这种差异是选择镜头或制作镜头动画时的关键创意考虑因素之一。</p><p>这是 After Effects 的示例，其中 7 个矩形排列在 3d 空间中，每个矩形相距 200 像素。使用 3 种不同的相机镜头设置（24 毫米、50 毫米和 135 毫米）渲染出相同的构图。</p><p><img src="/../images/post/AfterEffects%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/1699515287072.png" alt="1699515287072"></p><p>您可以清楚地看到差异。这样看来，教科书上的说法是正确的——与中间的镜头相比，广角镜头增加了矩形之间的距离，而长焦镜头则将它们压平了。</p><p>那么如果效果是真实的，为什么教科书上会稍有错误呢？</p><p>答案是因为这不仅仅是镜头本身。这实际上是 <strong>相机到拍摄对象的距离不同</strong> - 当镜头改变时，相机位置也会改变，以便取景保持不变。</p><p>如果我们考虑三个镜头——广角镜头、长焦镜头和中间的“普通”镜头——那么每次我们在这些镜头之间更换时，相机都会看到不同的结果。广角镜头将比“普通”镜头向我们展示更多的场景，而长焦镜头将向我们展示更少的场景。</p><p>但改变镜头会改变镜头的取景——而这并不是我们所说的我们正在做的事情。我们说过，我们将所有三个版本的取景都相同，为了做到这一点，我们需要移动相机以补偿不同的镜头。当我们使用广角镜头时，我们需要将相机向前移动，当我们使用长焦镜头时，我们需要向后移动相机。</p><p><img src="/../images/post/AfterEffects%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/1699515295006.png" alt="1699515295006"></p><p><em>场景的侧视图，显示 3 个摄像机位置和 7 个矩形。</em></p><p>当我们对场景进行构图以使三个镜头看起来相同时，我们的相机处于三个不同的位置。 </p><p><strong>导致照片看起来不同的是拍摄对象与相机位置的相对位置的差异，而不仅仅是镜头本身。</strong></p><p>正如我之前所说，视角的差异<em>是</em>存在的，这是摄影师经常使用的工具。通过使用长焦镜头从远处拍摄两个很远的物体，可以使它们看起来更近。当演员的安全很重要时，这在电影中经常被利用。 </p><p>例如，<a href="https://www.youtube.com/watch?v=9cb5Ka9SqGM">在电影《鲍芬格》中的高速公路场景中</a>，导演弗兰克·奥兹需要营造出艾迪·墨菲被超速行驶的汽车包围的印象。通过使用强大的长焦镜头从很远的地方拍摄特写镜头和剖面图，汽车可以与墨菲保持安全距离，同时看起来非常接近。这意味着特写镜头和切角镜头可以在摄像机内拍摄，无需特技替身或额外昂贵的绿屏视觉效果。</p><blockquote><p>镜头选择决定前景和背景物体如何出现的想法是如此普遍，以至于很容易忽视，实际上镜头选择<strong>和到相机的距离</strong>之间的关系才是重要的。</p></blockquote><p>对于异常高或窄的构图，需要考虑从主题到相机的距离。如果在相机靠近场景的情况下使用更广角的镜头，则场景的两侧会出现扭曲和扭曲，因为它们比中间距离相机远得多。解决这个问题的方法是将相机移得更远，并使用宽度较小的镜头，这样画面边缘的物体与相机的距离与中心的物体的距离更相似。</p><p><img src="/../images/post/AfterEffects%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/1699515304545.png" alt="1699515304545"></p><hr><h4 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h4><p>大多数人都熟悉广角和长焦镜头以及允许操作者手动调整镜头的变焦镜头的概念。然而，除了这些简单的术语之外，专业人士还需要能够更精确地描述镜头。</p><p>虽然“广角”和“长焦”这两个术语被广泛使用，但还有两种技术方法可以用来精确描述和测量镜头的特性。</p><p>在传统摄影中，换句话说，当我们拥有真正的相机时，惯例是以毫米为单位来描述镜头，这是对第一个镜头元件与图像聚焦表面之间距离的测量。 </p><p>因为我们指的是物理距离，所以这被称为镜头的 <strong>焦距。</strong> 您可能会看到描述为 50mm 镜头或 28mm 镜头的镜头——这就是焦距。50 毫米镜头意味着镜头距图像传感器 50 毫米，图像传感器现在是微芯片，但在过去是一条胶片。这是一个非常字面的术语。</p><p>出于本文的目的，我将使用术语“图像平面”来指代相机记录图像的点。如上所述，“图像平面”可以是相机中的胶片、宝丽来相机中的相纸、数码相机或手机中的 CCD，或者是旧金山桥暗箱中的墙壁。这基本上就是我们拍摄照片的焦点所在。</p><p>因此，镜头的焦距是从镜头到像平面的距离。</p><p>变焦镜头允许我们通过物理方式将镜头移得更远或更靠近图像平面来改变焦距。变焦镜头将按照其涵盖的最小到最大焦距进行描述，例如 28 – 80 毫米变焦。在这种情况下，镜头将在距离图像平面 28 毫米到 80 毫米之间进行物理滑动。这就是当您更改设置时变焦镜头会伸出的原因。 </p><p><img src="/../images/post/AfterEffects%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/1699515313782.png" alt="1699515313782"></p><p>镜头距离像平面越近，图像越宽，换句话说，您看到的越多。</p><p>镜头距离越远，场景放大得越多。你看不到侧面那么多。望远镜是长焦镜头的极端版本。</p><p>因此，广角镜头的焦距较小，而长焦镜头的焦距较长。</p><p>这就是长焦镜头这么长的原因之一——当你看到体育摄影师甚至狗仔队拿着大长焦镜头时，这是因为玻璃镜头距离图像传感器太远——这些镜头的焦距非常长。</p><p>摄影师和摄影导演也将此作为一种行话——您经常会听到摄影指导说某些东西是“用长镜头拍摄的”。</p><h4 id="光学极客演讲"><a href="#光学极客演讲" class="headerlink" title="光学极客演讲"></a>光学极客演讲</h4><p>一百多年来，摄影师一直很高兴地用焦距来描述他们的镜头。但当极客们参与进来并开始研究光学系统的科学和数学时，他们开始使用不同的系统。</p><p>数学家们不再用毫米为单位的焦距来描述镜头，而是更喜欢用度来描述镜头捕捉到的角度。这被称为视角或视野——大多数时候这些术语含义相同。</p><p><em>（在摄影中，视角始终以度为单位进行测量，但在某些特定的科学应用中，测量值可能会使用六十进制表示法列出——即分钟和秒的表示法，最常见的是与纬度和经度相关的。）</em></p><p>这是对镜头可以捕捉的场景角度的精确测量，就像通过镜头顶部的假想量角器进行测量一样。广角镜头会捕捉到较大的视角，因此具有较大的视角。长焦镜头的视角会更窄，因此视角会更小。 </p><p>因此，当谈到描述相机的镜头时，我们已经有两种替代方法。摄影师以毫米为单位测量焦距，而数学家以度为单位测量镜头可以捕捉的角度，将其称为视角或视场。</p><h4 id="术语混乱"><a href="#术语混乱" class="headerlink" title="术语混乱"></a>术语混乱</h4><p>想象一下我们只是用两种不同的方法来测量同一物体，并且将以毫米为单位的焦距转换为以度为单位的视角就像从摄氏温度转换为华氏温度一样简单，那就太好了。</p><p>不幸的是，这两种技术都不是那么简单，并且两种方法都涉及某种类型的歧义。那么让我们来看看这两种方法比看起来更复杂。</p><h4 id="mm这样的问题怎么解决"><a href="#mm这样的问题怎么解决" class="headerlink" title="mm这样的问题怎么解决"></a>mm这样的问题怎么解决</h4><p>当您通过焦距来描述镜头时，您正在记录一个非常字面的、真实的物理测量。50mm 镜头实际上距离像平面 50mm，在这方面不存在混淆或歧义。</p><p>这种方法的问题在于，相同的焦距对于不同尺寸的图像平面会产生 <em>不同的结果</em> 。同样的镜头，如果像面较小则可以认为是长焦镜头，如果像面较大则可以认为是广角镜头。</p><p>当摄影师过去使用胶片拍摄时，这不是问题，因为几乎每个地方的摄影师都使用相同尺寸的胶片（35 毫米）进行拍摄。35 毫米胶片是事实上的标准，唯一使用不同尺寸（例如 70 毫米中画幅胶片）的人是了解自己在做什么的专业人士。</p><p>因此，只要 35 毫米胶片是最流行的摄影格式，用毫米来描述镜头的焦距就非常有效，因为每个人都可以放心地假设焦距是相对于相同尺寸的图像平面而言的。</p><p>但如今摄影已由数码相机占据主导地位，并且<a href="https://en.wikipedia.org/wiki/Image_sensor_format">所使用的图像传感器有许多不同的尺寸</a>。有少数数码相机具有与 35mm 胶片相同尺寸的图像传感器，但通常有几种不同的尺寸可供选择，因此相同的<em>镜头</em>在不同的相机上会产生 <em>不同的结果</em> 。</p><p>这意味着仅靠焦距不足以描述镜头的表现，我们还需要像平面的大小来判断镜头是广角还是长焦。</p><p>这就是通过焦距描述镜头的问题：虽然以毫米为单位测量焦距可以为我们提供真实世界的测量结果，但我们不能单独使用焦距来预测镜头的性能，除非我们知道镜头的尺寸图像平面也是如此，这在不同的相机之间有所不同。</p><h4 id="唯一的方法是向上、向下或穿过"><a href="#唯一的方法是向上、向下或穿过" class="headerlink" title="唯一的方法是向上、向下或穿过"></a>唯一的方法是向上、向下或穿过</h4><p>通过测量视角来描述镜头似乎是一个更好的选择，但不幸的是这种方法也存在问题。</p><p>由于摄影镜头是圆形的，因此它们会生成圆形图像。无论镜头是鞋盒上的一个孔还是一块具有自动对焦和图像稳定功能的昂贵玻璃，它都会产生圆形图像。</p><p>如果我们生成圆形图像，那么通过视角来测量镜头就会很容易，因为圆形的定义属性之一是它在所有方向上具有相同的直径。无论我们以哪种方式测量圆，它都有相同的宽度——这相当于相同的视角。</p><p>问题在于照片、电影和电视节目一直都是以矩形的形式制作的。相机是否将图像记录到胶片、宝丽来相纸或数字图像传感器上并不重要——在所有现实情况下，从镜头中出来的圆形图像都会被裁剪成矩形。</p><p>许多不同的领域和学科都在使用许多不同的格式、尺寸和纵横比。即使我们只看电影和电视，也有<a href="https://en.wikipedia.org/wiki/Aspect_ratio_(image)">几种不同的宽高比</a>需要考虑 - 从最初的 1: 1.3 宽高比到当前的 Panavision 宽银幕宽高比 1: 2.39</p><p>当我们观察矩形而不是圆形时，例如电视使用的标准 16:9 宽高比，可以测量三个不同的轴作为“视角”——水平、垂直和对角线。</p><p>这意味着仅仅拥有“视角”并不足以了解镜头的性能，我们还需要知道测量是水平、垂直还是对角线。没有首选的通用标准——当我们有极端的纵横比时，它们之间的差异可能会非常大。数学家、计算机程序员、科学家和技术人员对测量视角的偏好各不相同，甚至计算机游戏中使用的不同 3D 引擎也使用不同的设置 — 有些是水平的，有些是对角线的。</p><p>这就是“视角”的问题——再一次，原始数字是不够的，我们还需要知道测量是水平、垂直还是对角线。当尝试将 After Effects 中的相机设置与其他应用程序中的相机设置进行匹配时，这直接相关。</p><hr><h4 id="这是传统"><a href="#这是传统" class="headerlink" title="这是传统"></a>这是传统</h4><p>我们可以总结到目前为止的一切：</p><p>1）镜头是基本的创作工具。</p><p>2）镜头和相机位置之间的关系决定了镜头的构图。</p><ol start="3"><li>镜头通过焦距（以毫米为单位）或视角（以度为单位）来测量。</li><li>在我们预测镜头的输出之前，这两种测量都需要额外的信息。</li></ol><p>5）镜头的焦距以毫米为单位，但我们需要知道像平面的大小才能判断镜头是广角还是长焦。</p><p>6）视角以度为单位测量，但我们还需要知道测量是水平、垂直还是对角线。</p><p>与理解这些差异同样重要的是理解这些术语在整个摄影史上的使用方式。</p><p>直到最近，35 毫米胶片一直是静态摄影中使用的主要胶片格式。35 毫米胶片格式<a href="https://en.wikipedia.org/wiki/35mm_film">非常古老</a>- 它于 1890 年代开发 - 并于 1909 年成为电影的官方标准。 </p><p>虽然早期的电影摄影机将胶片垂直地穿过摄影机并记录长宽比为 1: 1.3 的图像，但胶片尺寸的流行意味着许多制造商尝试对其进行调整以用于静态相机。通过将胶片水平地而不是垂直地穿过相机，可以捕获比电影摄影机更大的图像。早在 1914 年，静态相机就已开发出来，可以将 36 毫米 x 24 毫米的图像尺寸捕获到 35 毫米宽的胶片上，但不同公司提供了许多不同的变体。 </p><p>1925 年，徕卡发布了一款将 36 毫米 x 24 毫米图像尺寸记录到 35 毫米胶片上的相机，它变得非常受欢迎 - 到 20 世纪 50 年代，该尺寸已成为全球摄影师最流行的胶片格式。</p><p>从那时起，“35mm 摄影”一词就成为记录 36mm x 24mm 图像尺寸的代名词，并且至少 50 年来，这种格式已经如此普遍，以至于所有相机和摄影设备都被假定为用于 35mm 摄影，除非特别说明。这包括镜头。</p><p>由于摄影师假设每个人都在拍摄 35 毫米胶片并记录 36 毫米 x 24 毫米的图像尺寸，因此仅通过焦距来描述镜头，一代又一代的摄影师了解这些数字与他们制作的图像有何关系。</p><p>在某些时候，有人声称 50mm 镜头产生的图像与人眼所看到的图像（拍摄 35mm 胶片时）相匹配。这种说法已经被重复了很长时间，以至于它已经成为某种类型的摄影机构。如果你拿起一本关于摄影的书，那么它肯定就在里面的某个地方。</p><p>虽然 50 毫米镜头与人眼相当的想法并不正确，并且有很多关于该主题的网站文章和讨论，但 50 毫米镜头被认为是“标准”或“普通”镜头。这基本上意味着它不是广角镜头或长焦镜头，而是位于中间。这很正常。</p><p>50mm 镜头可以说是摄影基准。它是“正常”的简写。它被认为是所有其他镜头的起点或参考点。 </p><p>50mm 镜头被视为“标准”，任何焦距较小的镜头都被视为广角镜头，任何焦距较大的镜头都被视为长焦镜头。随着时间的推移，特定焦距变得流行，并被认为是摄影师的主要工具。</p><p>35毫米和28毫米镜头是流行的广角镜头，而焦距在80至105毫米之间的镜头通常被称为“人像”镜头，因为它们很受拍摄人像的摄影师的欢迎。这也值得评论一下，因为很多摄影书籍都会声称，80-105毫米左右焦段的镜头很受人像摄影师的欢迎，因为它们使脸部稍微变平，使人看起来更有魅力。 </p><p>这是我们之前看到的关于透视的同一主张的更具体版本，完整的解释再次与相机的位置有关。如果摄影师必须使用普通 50 毫米或更宽的镜头拍摄肖像，那么他们需要离拍摄对象非常近。这不仅让所有参与者感到不舒服，而且还可能导致光照和阴影的实际问题。如果摄影师使用比 105 毫米长得多的镜头，那么他们就必须距离拍摄对象几米远——这在小型工作室中是不可能的，即使是这样，也对亲密感没有什么帮助。使用焦距在 80 至 105 毫米之间的镜头意味着摄影师与拍摄对象之间的距离舒适且实用，因此很受欢迎。</p><p>确实，在相同的取景范围下，用 105mm 镜头拍摄的人像会比用 50mm 镜头拍摄的人像看起来“更平”，但拍摄对象的外观更漂亮，这只能说明较长镜头是首选的一半原因。400mm 镜头可能更讨人喜欢，但如果摄影师必须站在 10 米之外，它就没那么有用了。</p><p>当数值非常低时，镜头会产生独特的“<a href="https://www.google.com.au/search?q=fisheye&source=lnms&tbm=isch&sa=X&ei=_op5U73qKcfdkAW63ICYDA&ved=0CAYQ_AUoAQ&biw=1620&bih=1025">鱼眼</a>”效果，而当数值非常高时，相机就像望远镜一样——阿尔弗雷德·希区柯克在电影《后窗》中将这种效果用作叙事手段。</p><p>由于数码摄影已经超越了 35mm 胶片， <em>摄影师仍然会根据镜头与 35mm 胶片的表现来参考镜头</em> ，尽管数码图像传感器的尺寸可能有所不同。一些制造商会给出“转换系数”或“<a href="https://en.wikipedia.org/wiki/Crop_factor">裁剪系数</a>”，以便用于描述镜头的数字可以转换为 35mm 行业标准。 </p><p>例如，佳能 APS-C 镜头的转换系数为 1.6。这意味着 APS-C 相机上的 31.25mm 镜头将产生与 35mm 相机上的 50mm 镜头相同的图像 (31.25 x 1.6 &#x3D; 50)，或者 APS-C 相机上的 50mm 镜头相当于 80mm 35mm 相机上的镜头 (50 x 1.6 &#x3D; 80)。</p><hr><h4 id="After-Effects-–-进入虚拟世界"><a href="#After-Effects-–-进入虚拟世界" class="headerlink" title="After Effects – 进入虚拟世界"></a>After Effects – 进入虚拟世界</h4><p>3D 图层和 After Effects 相机于 2001 年在版本 5 中引入。与现实世界的相机一样，After Effects 中的虚拟相机也配备了可以放大和缩小的虚拟“镜头”。</p><p><img src="/../images/post/AfterEffects%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/1699515335401.png" alt="1699515335401"></p><p>自 2001 年版本 5 以来，After Effects 相机已逐步改进并增加了一些额外的控件和设置。After Effects 中的各种参数直接与其现实世界中的等效参数相关，但虽然基本原理与现实世界摄影相同，但仍需要考虑一些重要因素。</p><p>首先，After Effects 使用像素进行操作。它不适用于毫米、英寸或米等测量单位。 </p><p>其次，After Effects 遵循数十年的传统，使用 35mm 摄影作为镜头预设的参考。</p><p>在 After Effects 时间轴中，相机“镜头”由“缩放”参数控制，该参数以像素为单位。我们可以将变焦参数视为等效于焦距——较小的值使我们视野更宽，较大的值使我们能够放大。</p><p>然而，当我们进入相机设置时，我们还会看到预设镜头列表，按焦距（以毫米为单位）列出。选择这些预设之一会导致缩放参数设置为 After Effects 等效像素值。</p><p>After Effects 还向我们展示了等效视角（以度为单位）。我们可以指定测量是水平、垂直还是对角线进行。</p><p>After Effects 的早期版本没有明确解释与 35mm 摄影相关的镜头预设，但当前版本还允许您更改“胶片尺寸”，并指定不同单位的测量值。</p><p><strong>即使您输入自定义胶片尺寸，只要您选择镜头预设，这些值就会变回 36 毫米 x 24 毫米——35 毫米胶片照片的尺寸。</strong></p><p>如果您添加带有广角镜头的新相机，After Effects 会将相机放置在更靠近构图的位置；如果您添加带有长焦镜头的新相机，则新相机会放置在更远的位置。</p><p><img src="/../images/post/AfterEffects%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/1699515343606.png" alt="1699515343606"></p><p>但是，如果您打开现有相机的设置并选择不同的预设，则 After Effects 不会更改相机位置。这意味着您可以直接比较不同的镜头类型。因此，如果您已经添加了相机并使用了 50mm 预设，则更改相机设置将改变输出 - 35mm 预设将为您提供更宽的视野，而 200mm 预设将显着放大图像。</p><h4 id="After-Effects-相机设置"><a href="#After-Effects-相机设置" class="headerlink" title="After Effects 相机设置"></a>After Effects 相机设置</h4><p>现在，我们可以了解相机设置的作用，以及 After Effects 如何使用不同的参数。</p><p>After Effects 以像素而不是毫米为单位测量镜头的焦距。</p><p>只要图层与相机的距离（以像素为单位）与镜头焦距相同，它就会显示为 100% 比例 - 换句话说，它看起来很正常。每次您在 After Effects 中创建新相机时，它都会自动将相机的 z 位置设置为与“缩放”相同。</p><p><img src="/../images/post/AfterEffects%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/1699515350135.png" alt="1699515350135"></p><p>随着图层远离相机，它们看起来更小。我们可以通过测量图层到相机的距离并将其计算为缩放的百分比来计算它们需要放大的量，以便它们看起来相同的大小 - 我们很快就会这样做。</p><h4 id="温暖而模糊"><a href="#温暖而模糊" class="headerlink" title="温暖而模糊"></a>温暖而模糊</h4><p>After Effects 中的相机设置还包括景深控制。景深是指场景中有多少部分清晰可见，在 After Effects 中，可以根据需要打开或关闭该景深。</p><p><img src="/../images/post/AfterEffects%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/1699515360702.png" alt="1699515360702"></p><p>如果关闭景深设置，则一切都始终清晰。打开后，相机会“聚焦”在特定的距离（可以控制和设置动画），距离焦点越远，图层就会显得越模糊。</p><p>在现实世界中，景深是由镜头光圈的大小来控制的——说白了就是让光线进入的孔的大小。孔越大，景深越小——物体越少。焦点。当光圈很小时，景深就很大——换句话说，一切都在焦点上。摄影师以 F 值来测量光圈，大多数真实相机镜头的 F 值范围约为 F4 到 F22。超出这个范围——特别是对于较低的数字——镜头很快就会变得非常昂贵。幸运的是，软件中的虚拟相机可以轻松实现小于 1 的光圈值，这在现实生活中几乎是不可能的。</p><p>在现实世界中拍照时，摄影师的选择受到可用光线量的限制。在很多情况下，摄影师可能希望使用特定的光圈值来实现所需的景深，但根本没有足够的光线。摄影师必须平衡创意意图和技术要求，才能拍出真正有效的照片。换句话说，在现实世界中，如果摄影师设置错误，那么照片就不会出来——它可能太暗或太亮。</p><p>使用软件中的虚拟相机，不存在曝光和光线问题，因此可以设置光圈控制来创建所需的景深，而不必担心可用的光线量。</p><p>随着设置的调整，也更容易看到光圈的效果 - 因此通常可以拖动光圈设置并实时预览，直到您对结果感到满意为止。</p><p>在相机设置对话框中，After Effects 允许您将光圈指定为光圈值，但在时间轴中光圈以像素为单位列出。有一些公式可以根据镜头焦距和光圈计算景深，但它们超出了本文的范围。</p><p><img src="/../images/post/AfterEffects%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/1699515382533.png" alt="1699515382533"></p><p>但基本上——光圈越大，图像越模糊。</p><hr><h4 id="缩小规模，缩小规模，缩小规模"><a href="#缩小规模，缩小规模，缩小规模" class="headerlink" title="缩小规模，缩小规模，缩小规模"></a>缩小规模，缩小规模，缩小规模</h4><p>在许多应用程序中，无论图层位于 3D 空间中的何处，都可以使图层显示相同的大小。那么让我们看看图层的比例与相机的变焦和位置有何关系。我在这里使用的数字对应于 1920 x 1080 的合成，并想象我们已经创建了一个相同大小的实体并将其设为 3D 图层。它的 z 位置为 0。</p><p>当我们使用 50mm 镜头预设创建新相机时，After Effects 会将其转换为 2666.7 像素的“缩放”值。它还将相机定位为 az 值为 -2666.7 。因为我们的图层的 z 位置为 0，这意味着它距相机 2666.7 像素。因为这与缩放值相同，所以图层显示的大小完全相同 - 100%。 </p><p><img src="/../images/post/AfterEffects%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/1699515389933.png" alt="1699515389933"></p><blockquote><p>当 3D 图层与相机的距离与缩放值相同时，它将显示与 100% 的 2D 图层相同的大小。</p></blockquote><p>如果我们将 3D 图层移得更远，它看起来会更小 – 这就是您所期望的！如果我们将图层的 z 位置设置为 3000，则它现在距相机 5666.7 像素 (2666.7 + 3000)。</p><p>如果我们将新距离除以缩放值，我们就可以得到缩放百分比形式的距离。</p><p>(5666.7 &#x2F; 2666.7) * 100 &#x3D; 212.49%</p><p>如果我们采用该值并将图层放大到 212.49%，则图层将再次填充合成并显示为全尺寸。</p><p>反之亦然。如果我们将图层移得更近 - 例如，z 位置为 -500，那么它现在距相机 2166.7 像素。这相当于缩放值的 81.25%，如果我们将图层缩放到 81.25%，那么它会再次显示为原始大小。</p><p>我们可以使用表达式动态计算比例百分比，这样我们就可以为图层和相机设置动画，而无需自己重新进行数学计算。</p><p>我们将从一个简单的示例开始，出于示例的目的，我们假设相机称为“相机 1”。</p><p>Campos&#x3D;thisComp.layer(“相机1”).toWorld([0,0,0]);</p><p>Zoom&#x3D;thisComp.layer(“相机1”).cameraOption.zoom;</p><p>lpos&#x3D;thisLayer.toWorld(thisLayer.anchorPoint);</p><p>d&#x3D;长度(campos,lpos); &#x2F;&#x2F; 图层到相机的距离 &#x2F;&#x2F;</p><p>scl&#x3D;(d&#x2F;缩放)*100;</p><p>[scl,scl,100]</p><p>您可以将此表达式剪切并粘贴到 3D 图层的缩放值中，无论相机距离多远，它始终会显示为缩放为 100%。</p><h4 id="数学，数学，数学，这就是他们所想的一切"><a href="#数学，数学，数学，这就是他们所想的一切" class="headerlink" title="数学，数学，数学，这就是他们所想的一切"></a>数学，数学，数学，这就是他们所想的一切</h4><p>在 After Effects 中，相机设置对话框会向您显示您需要了解的所有内容，并为您完成所有计算和转换。然而，当您进入脚本和表达式时，了解如何自己进行这些转换可能会很有用。</p><p>存在三个相互关联的基本属性，任意两个都可以用来计算第三个：</p><p>– 变焦（焦距以像素为单位）</p><p>– 视角（以度为单位）</p><p>– 对角线大小（以像素为单位）</p><p>我之前指出，通过视角描述镜头的问题之一是您还需要知道正在测量哪个尺寸。当涉及到镜头和光学的数学时，会使用对角线。 </p><p>我们可以使用毕达哥拉斯定理从构图的宽度和高度计算构图的对角线长度。这是高中教授的简单 C ^2^ &#x3D;A ^2^ +B ^2公式，但我们可以在这里将其写为 After Effects 表达式：^</p><p>w&#x3D;thisComp.宽度；</p><p>h&#x3D;thisComp.height;</p><p>hyp&#x3D;Math.sqrt((w<em>w)+(h</em>h));</p><p>正如我们在高中时所知，三角形对角边的术语是斜边，因此我使用了变量名称 hyp。</p><p>如果我们知道对角线的大小和视角，那么我们就可以计算出焦距。在 After Effects 中，焦距以像素为单位进行测量。我遇到过几次从 Maya 导入的摄像机的缩放值错误的情况，如果您知道 Maya 中摄像机的视角，那么您可以为 After Effects 计算正确的像素值。</p><p>由于 After Effects 使用 Javascript 进行表达式，因此我们必须注意度数和弧度的使用。使用相机时，视角以度为单位，但 Javascript 中的三角计算是使用弧度完成的。由于我们将使用正切和反正切函数，因此在进行数学计算之前，我们需要将视角转换为弧度。</p><p>作为示例，我们将计算 1920 x 1080 构图中 50mm 相机的变焦值（After Effects 中焦距的术语）。从相机设置对话框中我们知道，如果我们选择 50mm 镜头预设，则视角（对角线）为 44.9 度。</p><p>w&#x3D;thisComp.宽度；</p><p>h&#x3D;thisComp.height;</p><p>hyp&#x3D;Math.sqrt((w<em>w)+(h</em>h));</p><p>aov&#x3D;44.9；&#x2F;&#x2F; 视角（以度为单位） &#x2F;&#x2F;</p><p>rad&#x3D;degsToRadians(aov&#x2F;2); &#x2F;&#x2F; 转换为弧度 &#x2F;&#x2F;</p><p>缩放&#x3D;hyp&#x2F;(2*Math.tan(rad))</p><p>[飞涨]</p><p>如果您自己尝试一下，您会发现给定的缩放值为 2665.7，这与 After Effects 给您的默认值 2666.7 略有不同。这是由于较小的舍入误差造成的，因为 After Effects 只为我们提供了一位小数点后的视角。如果我们输入视角为 44.885 而不是 44.9，那么我们得到的结果是 2666.7。</p><p>我们还可以将 After Effects 中的缩放值转换为以度为单位的视角。如果我们已经在 After Effects 中创建了相机缩放设置并对其进行了动画处理，并且想要将数字转换到使用视角定义相机的不同应用程序（例如 Maya），那么这非常有用。</p><p>w&#x3D;thisComp.宽度；</p><p>h&#x3D;thisComp.height;</p><p>hyp&#x3D;Math.sqrt((w<em>w)+(h</em>h));</p><p>缩放&#x3D;2666.7；</p><p>aov&#x3D;2<em>Math.atan(hyp&#x2F;(zoom</em>2));</p><p>aov&#x3D;radiansToDegrees(aov);</p><p>[aov]</p><p>如果您尝试此操作，您将看到给定的视角值为 44.885 度 - 比相机设置框中显示的 44.9 度更精确的值。</p><p>这也是一个很好的例子，说明了在表达式中使用角度和弧度是如何令人困惑的。在第一个示例中，我们从以度为单位描述的视角开始，因此在调用正切函数之前，我们必须将其转换为弧度。</p><p>然而，在第二个示例中，我们使用反正切函数，但我们输入的值不是以度为单位的测量值 - 它是斜边与焦距的比率。该比率不是以度数来测量的，因此无需将其转换为弧度。众所周知，混合度数和弧度通常是一件痛苦的事情，在这种情况下，我们必须确保我们不会得意忘形，并在不必要时进行转换。</p><p>最后，如果我们知道变焦值和视角，那么我们就可以计算出斜边的尺寸，或者构图的对角线尺寸。因为我们从以度为单位测量的视角开始，所以我们必须首先将值转换为弧度。</p><p>缩放&#x3D;2666.7；</p><p>aov&#x3D;44.885；</p><p>rad&#x3D;度数转弧度(aov);</p><p>hyp&#x3D;2<em>缩放</em>(Math.tan(rad&#x2F;2));</p><p>[嗨]</p><h4 id="规模化——凭感觉"><a href="#规模化——凭感觉" class="headerlink" title="规模化——凭感觉"></a>规模化——凭感觉</h4><p>前面我们列出了一个简单的表达式，用于计算将图层保持 100% 大小所需的比例，无论相机位于何处。</p><p>我们可以更新此表达式以考虑图层的比例，这样我们就不必假设图层为 100%。我们仍然可以向上或向下缩放图层，并且它会随着相机的移动而保持不变：</p><p>Campos&#x3D;thisComp.layer(“相机1”).toWorld([0,0,0]); &#x2F;&#x2F; 相机位置 &#x2F;&#x2F;</p><p>Zoom&#x3D;thisComp.layer(“相机1”).cameraOption.zoom; &#x2F;&#x2F; 相机变焦 &#x2F;&#x2F;</p><p>lpos&#x3D;thisLayer.toWorld(thisLayer.anchorPoint); &#x2F;&#x2F; 图层位置 &#x2F;&#x2F;</p><p>lscl&#x3D;thisLayer.transform.scale; &#x2F;&#x2F; 图层比例 &#x2F;&#x2F;</p><p>d&#x3D;长度(campos,lpos); &#x2F;&#x2F; 图层到相机的距离 &#x2F;&#x2F;</p><p>xscl&#x3D;lscl[0];yscl&#x3D;lscl[1];zscl&#x3D;lscl[2];</p><p>x&#x3D;(d&#x2F;缩放)*xscl;</p><p>y&#x3D;(d&#x2F;缩放)*yscl;</p><p>z&#x3D;(d&#x2F;缩放)*zscl;</p><p>[x,y,z]</p><p>如果将此表达式应用于 3D 图层的缩放属性，即使相机改变位置，它也将始终显示相同的大小。</p><hr><h4 id="兴趣表达"><a href="#兴趣表达" class="headerlink" title="兴趣表达"></a>兴趣表达</h4><p>2001 年随 After Effects 版本 5 推出的虚拟相机具有与现实世界相机相同的所有品质，即使某些术语略有不同。</p><p>对于 After Effects 表达者、脚本编写者或只是好奇的人来说，需要了解一些基本知识才能更有效地使用相机。</p><p>– 相机设置对话框中的镜头预设与 35mm 摄影相关。50mm预设被认为是普通镜头。</p><p>– After Effects 将焦距称为“缩放”，并以像素为单位进行测量。</p><p>– 创建新相机时，After Effects 会自动定位新相机，使其与合成中心的距离与“缩放”值相同。 </p><p>– 当图层与相机的距离与“缩放”量相同时，它将显示为 100% 的 2D 图层。</p><p>虚拟相机具有三个主要的定义属性——焦距、视角和图像平面的对角线尺寸——任意两个都可以用来计算第三个属性。</p><p><strong>&#x2F;&#x2F; 使用视角计算镜头的“变焦”（焦距） &#x2F;&#x2F;</strong></p><p>w&#x3D;thisComp.宽度；</p><p>h&#x3D;thisComp.height;</p><p>hyp&#x3D;Math.sqrt((w<em>w)+(h</em>h));</p><p>aov&#x3D;44.9；&#x2F;&#x2F; 视角（以度为单位） &#x2F;&#x2F;</p><p>rad&#x3D;degsToRadians(aov&#x2F;2); &#x2F;&#x2F; 转换为弧度 &#x2F;&#x2F;</p><p>缩放&#x3D;hyp&#x2F;(2*Math.tan(rad))</p><p>[飞涨]</p><p><strong>&#x2F;&#x2F; 根据相机的变焦值计算视角 &#x2F;&#x2F;</strong></p><p>w&#x3D;thisComp.宽度；</p><p>h&#x3D;thisComp.height;</p><p>hyp&#x3D;Math.sqrt((w<em>w)+(h</em>h));</p><p>缩放&#x3D;2666.7；</p><p>*&#x2F;&#x2F; Zoom &#x3D; thisComp.layer(“相机1”).cameraOption.zoom; *或者直接从相机获取值&#x2F;&#x2F;</p><p>aov&#x3D;2<em>Math.atan(hyp&#x2F;(zoom</em>2));</p><p>aov&#x3D;radiansToDegrees(aov);</p><p>[aov]</p><p><strong>&#x2F;&#x2F; 根据相机的变焦和视角计算图像位置的对角线尺寸 &#x2F;&#x2F;</strong></p><p>缩放&#x3D;2666.7；</p><p><em>&#x2F;&#x2F; Zoom &#x3D; thisComp.layer(“相机1”).cameraOption.zoom; 或者直接从相机获取值 &#x2F;&#x2F;</em></p><p>aov&#x3D;44.885；</p><p>rad&#x3D;度数转弧度(aov);</p><p>hyp&#x3D;2<em>缩放</em>(Math.tan(rad&#x2F;2));</p><p>[嗨]</p><p><strong>&#x2F;&#x2F; 自动缩放 3D 图层，使其始终显示相同的大小 &#x2F;&#x2F;</strong></p><p>&#x2F;&#x2F; 假设活动相机称为“Camera 1” – 相应更改 &#x2F;&#x2F;</p><p>Campos&#x3D;thisComp.layer(“相机1”).toWorld([0,0,0]); &#x2F;&#x2F; 相机位置 &#x2F;&#x2F;</p><p>Zoom&#x3D;thisComp.layer(“相机1”).cameraOption.zoom; &#x2F;&#x2F; 相机变焦 &#x2F;&#x2F;</p><p>lpos&#x3D;thisLayer.toWorld(thisLayer.anchorPoint); &#x2F;&#x2F; 图层位置 &#x2F;&#x2F;</p><p>lscl&#x3D;thisLayer.transform.scale; &#x2F;&#x2F; 图层比例 &#x2F;&#x2F;</p><p>d&#x3D;长度(campos,lpos); &#x2F;&#x2F; 图层到相机的距离 &#x2F;&#x2F;</p><p>xscl&#x3D;lscl[0];yscl&#x3D;lscl[1];zscl&#x3D;lscl[2];</p><p>x&#x3D;(d&#x2F;缩放)*xscl;</p><p>y&#x3D;(d&#x2F;缩放)*yscl;</p><p>z&#x3D;(d&#x2F;缩放)*zscl;</p><p>[x,y,z]</p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ae </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影构图</title>
      <link href="/2023/12/28/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/"/>
      <url>/2023/12/28/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="构图方法"><a href="#构图方法" class="headerlink" title="构图方法"></a>构图方法</h1><h2 id="一、点构图"><a href="#一、点构图" class="headerlink" title="一、点构图"></a>一、点构图</h2><h3 id="1-点构图"><a href="#1-点构图" class="headerlink" title="1.点构图"></a>1.点构图</h3><p>中心点构图：<br>把画面主题放在照片中心<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657205928.png" alt="1703657205928"></p><p>基础构图方式之一，使得照片常规而稳重，不会犯错。<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657221835.png" alt="1703657221835"><br>但缺点是容易让照片显得比较呆板缺乏活力。</p><h3 id="2-三分点构图"><a href="#2-三分点构图" class="headerlink" title="2.三分点构图"></a>2.三分点构图</h3><p><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657254961.png" alt="1703657254961"><br>把照片长和宽都三等分会出现水平线和垂直线相交的4个点<br>三分点构图即把画面主体放在这4个点上</p><p><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657533586.png" alt="1703657533586"><br>画面会比较和谐</p><p><img src="https://i0.hdslb.com/bfs/note/8583dd29b1304f91132d38689b972d3bd5f2650b.jpg@680w_!web-note.webp"><br>相比中心点构图更富于变化</p><p><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657528937.png" alt="1703657528937"></p><p>注意事项：<br>打开辅助线<br>三分点构图有时会让画面不平衡<br>可在相对三分点放入另一元素平衡画面<br>如果想强调地面，可把水平线放在上三分线</p><p><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657523230.png" alt="1703657523230"><br>如果想强调天空，可把水平线放在下三分线</p><p><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657517813.png" alt="1703657517813"></p><p>人像构图注意：<br>垂直三分线构图拍摄人像<br>要留意人物朝向<br>如果没有特别的想法，建议人物朝右，放在左三分线</p><p><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657509842.png" alt="1703657509842"><br>人物朝左就放在右三分线</p><p><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657488227.png" alt="1703657488227"><br>不然给人感觉像在面壁思过一样</p><h2 id="二、线构图"><a href="#二、线构图" class="headerlink" title="二、线构图"></a>二、线构图</h2><h3 id="3-对角线构图"><a href="#3-对角线构图" class="headerlink" title="3.对角线构图"></a>3.对角线构图</h3><p>利用照片对角线进行构图<br>一般横平竖直让人感到稳定安心<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657592717.png" alt="1703657592717"><br>倾斜会产生动感和不稳定<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657598678.png" alt="1703657598678"><br>因此对角线构图常常用在运动<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657619508.png" alt="1703657619508"><br>和要表现一定情绪的人物照片中<br>以及表达一些想法的创意照中<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657624090.png" alt="1703657624090"></p><p>注意事项：<br>打开辅助线<br>画面主题建议聚焦在三分点<br>这样的照片会更加舒服<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657641286.png" alt="1703657641286"></p><h3 id="4-曲线构图"><a href="#4-曲线构图" class="headerlink" title="4.曲线构图"></a>4.曲线构图</h3><p>利用自然存在的曲线，或者人为寻找的曲线进行构图<br>最一般的是S型曲线<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657659330.png" alt="1703657659330"><br>曲线构图比较多应用在画面中存在道路河流等元素的照片中<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657665289.png" alt="1703657665289"></p><h3 id="5-引导线构图"><a href="#5-引导线构图" class="headerlink" title="5.引导线构图"></a>5.引导线构图</h3><p>利用画面中的线条<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657681106.png" alt="1703657681106"><br>把观众的目光引导到画面主体上<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657684757.png" alt="1703657684757"><br>这样构图的好处是很容易突出主体<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657688565.png" alt="1703657688565"><br>同时引导线的存在加强了画面的层次感<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657696381.png" alt="1703657696381"></p><p>注意：<br>引导的主体建议<br>处于画面中心点或三分点<br>这样照片也会更舒服一些<br>线构图简单但十分灵活，是大家拍照运用最广泛的<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657705406.png" alt="1703657705406"></p><h2 id="三、面构图"><a href="#三、面构图" class="headerlink" title="三、面构图"></a>三、面构图</h2><h3 id="6-前景构图"><a href="#6-前景构图" class="headerlink" title="6.前景构图"></a>6.前景构图</h3><p>在画面中，前面的景别叫做前景<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657723584.png" alt="1703657723584"><br>在画面中加入前景，让画面更有趣的同时<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657738881.png" alt="1703657738881"><br>也可以给照片营造空间立体感<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657745415.png" alt="1703657745415"></p><p>注意：<br>前景最好和主题有关联<br>不要为了前景构图而加入不合适前景</p><h3 id="7-框架构图"><a href="#7-框架构图" class="headerlink" title="7.框架构图"></a>7.框架构图</h3><p>是前景构图的特殊形式<br>把例如门，窗等框架作为一种前景<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657762052.png" alt="1703657762052"><br>框架构图除了具有前景构图的好处外<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657766884.png" alt="1703657766884"><br>还能更加突出画面主题<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657770680.png" alt="1703657770680"></p><h3 id="8-填充构图"><a href="#8-填充构图" class="headerlink" title="8.填充构图"></a>8.填充构图</h3><p>让画面主体尽量充满整个画面<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657819961.png" alt="1703657819961"><br>特别是用手机常用镜头或者广角镜头拍摄时<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657824101.png" alt="1703657824101"><br>会产生透视引发形状变化<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657827531.png" alt="1703657827531"><br>填充构图常常用在表现夸张情绪的人物或者动物照片中<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657831136.png" alt="1703657831136"></p><h3 id="9-留白构图"><a href="#9-留白构图" class="headerlink" title="9.留白构图"></a>9.留白构图</h3><p>和填充构图相反<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657843997.png" alt="1703657843997"><br>除了画面主体以外，在画面中尽可能留白，极致地做画面减法<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657847864.png" alt="1703657847864"><br>留白构图在一些小清新照片中用的比较多<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657851535.png" alt="1703657851535"></p><h3 id="10-重复构图"><a href="#10-重复构图" class="headerlink" title="10.重复构图"></a>10.重复构图</h3><p>当画面中有比较多重复元素的时候，<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657868449.png" alt="1703657868449"><br>可以尝试用重复构图把画面中的元素进行重复排列<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657872429.png" alt="1703657872429"></p><p>注意：<br>元素排列最好基于某种排列逻辑<br>否则画面会很乱</p><p>11.对比构图</p><p>和重复构图相对的<br>在重复的元素中运用某一种方式突出其中的某一个元素<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657903500.png" alt="1703657903500"><br>这种方式可以是不同颜色对比<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657915687.png" alt="1703657915687"><br>可以是运动和静止对比<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657920899.png" alt="1703657920899"><br>可以是不同光影条件下的对比等等<br><img src="/../images/post/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/1703657925387.png" alt="1703657925387"></p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象编程</title>
      <link href="/2022/07/02/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/07/02/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>整理人：尚硅谷 - 宋红康</p><h2 id="面向对象学习三条主线"><a href="#面向对象学习三条主线" class="headerlink" title="面向对象学习三条主线"></a><strong>面向对象学习三条主线</strong></h2><p>1、Java类及类的成员：属性、方法、构造器；代码块、内部类</p><p>2、面向对象三大特征：封装性、继承性、多态性、（抽象性）</p><p>3、其他关键字：this、super、final、abstract、interface</p><h2 id="面向过程-POP-与-面向对象-OOP"><a href="#面向过程-POP-与-面向对象-OOP" class="headerlink" title="面向过程(POP) 与 面向对象(OOP)"></a><strong>面向过程(POP) 与 面向对象(OOP)</strong></h2><p>面向过程：强调功能行为，以函数为最小单位，考虑怎么做</p><p>面向对象：强调具备功能的对象，以“类\对象”为最小单位，考虑谁来做</p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.png" alt="img" title="面向过程与面向对象"></p><p>如何理解面向对象：万物皆对象。可以以公司运营为例子。初创公司可能是面向过程，以解决方法优先，强调方法。公司发展后设立财务部、人力资源部等部门，按功能设立部门和分配员工，强调具有功能的类\对象。在Java中把功能封装到类中，通过类的实例化来调用功能。</p><h2 id="Java类及类的成员"><a href="#Java类及类的成员" class="headerlink" title="Java类及类的成员"></a><strong>Java类及类的成员</strong></h2><p>Field &#x3D; 属性 &#x3D; 成员变量，Method &#x3D; (成员)方法 &#x3D; 函数</p><p>类的实例化，即创建类的对象</p><p>如果创建了一个类的多个对象，对于类中定义的属性（非static），每个对象都拥有各自的一套副本，且互不干扰。</p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%9E%84%E6%88%90.png" alt="img" title="类的成员构成"></p><pre><code class="language-java">Person p1 = new Person();p1.age = 13;Person p3 = p1;p3.age = 10;System.out.println(p1.age);//10</code></pre><h2 id="内存解析"><a href="#内存解析" class="headerlink" title="内存解析"></a>内存解析</h2><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.png" alt="img" title="内存解析"></p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%902.png" alt="img" title="内存解析2"></p><h2 id="类的成员之一：属性-field"><a href="#类的成员之一：属性-field" class="headerlink" title="类的成员之一：属性(field)"></a>类的成员之一：属性(field)</h2><h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><p>相同点：即变量的特点</p><p>不同点：</p><p>成员变量（属性）直接定义在类中（类{}中）；局部变量声明在方法内、方法形参、代码块内、构造器内。</p><p>声明属性的常用权限修饰符修饰：public、private、default（不写即默认）、protected；局部变量不可以用权限修饰符，可以用final</p><p>属性有初始值；局部变量在调用前一定要显示赋值（形参调用时赋值就可以）</p><p>内存：属性在堆空间（非static，static在方法区），局部变量在栈空间</p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.png" alt="img" title="成员变量与局部变量"></p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="img" title="&#x2F;成员变量与局部变量的区别"></p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%80%BC.png" alt="img" title="成员变量初始值"></p><h2 id="类的成员之二：方法-method"><a href="#类的成员之二：方法-method" class="headerlink" title="类的成员之二：方法(method)"></a>类的成员之二：方法(method)</h2><p>方法的声明格式：</p><pre><code class="language-java">修饰符 返回值类型 方法名（参数类型 形参1, 参数类型 形参2, ….）｛方法体程序代码return 返回值;｝</code></pre><p>static、final、abstract来修饰的方法，后面再讲</p><p>返回值类型：</p><ul><li>没有返回值：void。</li><li>有返回值，声明出返回值的类型。与方法体中“return 返回值”搭配使用</li></ul><p>return作用：①<code>return;</code>结束方法②返回值</p><p>方法：在使用时可以调用类的属性或方法</p><h3 id="1：方法的重载-overload"><a href="#1：方法的重载-overload" class="headerlink" title="1：方法的重载(overload)"></a>1：方法的重载(overload)</h3><p>重载的概念<br>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数<br>类型不同即可。<br>重载的特点：<br>与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类<br>型，包括顺序，但参数名不看)。调用时，根据方法参数列表的不同来区别。<br>重载示例：</p><pre><code class="language-java">//返回两个整数的和int add(int x,int y)&#123;return x+y;&#125;//返回三个整数的和int add(int x,int y,int z)&#123;return x+y+z;&#125;//返回两个小数的和double add(double x,double y)&#123;return x+y;&#125;</code></pre><h3 id="2：可变个数的形参"><a href="#2：可变个数的形参" class="headerlink" title="2：可变个数的形参"></a>2：可变个数的形参</h3><p>JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定<br>义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可<br>变的实参。</p><pre><code class="language-java">//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量public static void test(int a ,String[] books);//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量public static void test(int a ,String…books);</code></pre><p>说明：</p><ol><li>声明格式：方法名(参数的类型名 …参数名)</li><li>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个</li><li>可变个数形参的方法与同名的方法之间，彼此构成重载</li><li>可变参数方法的使用与方法参数部分使用数组是一致的</li><li>方法的参数部分有可变形参，需要放在形参声明的最后</li><li>在一个方法的形参位置，最多只能声明一个可变个数形参</li></ol><pre><code class="language-java">public void test1(String book)&#123;System.out.println(“****与可变形参方法构成重载的test1方法****&quot;);&#125;public void test1(String ... books)&#123;System.out.println(&quot;****形参长度可变的test1方法****&quot;);&#125;</code></pre><h3 id="▲方法3：方法参数的值传递机制"><a href="#▲方法3：方法参数的值传递机制" class="headerlink" title="▲方法3：方法参数的值传递机制"></a>▲方法3：方法参数的值传递机制</h3><p>方法，必须由其所在类或对象调用才有意义。若方法含有参数：<br>形参：方法声明时的参数<br>实参：方法调用时实际传给形参的参数值<br> Java的实参值如何传入方法呢？<br>Java里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。</p><ul><li>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</li><li>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</li></ul><p>详细可以再看课程或课件</p><h2 id="对象数组的内存解析"><a href="#对象数组的内存解析" class="headerlink" title="对象数组的内存解析"></a>对象数组的内存解析</h2><p>数组是引用类型，那元素既可以是基本类型也可以是引用类型。</p><p>引用类型的变量，只可能存储两类值：null和地址值（包含变量类型）</p><p><img src="/source/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.png" alt="img" title="对象数组内存解析"></p><h3 id="引用类型数组小细节"><a href="#引用类型数组小细节" class="headerlink" title="引用类型数组小细节"></a>引用类型数组小细节</h3><p>一般对象数组返回的是地址值，而char[]返回的是字符串，是因为sout.println方法对两者的重载</p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%B0%8F%E7%BB%86%E8%8A%82.png" alt="img" title="对象数组小细节"></p><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>1、创建的对象，没有显示赋给变量名，即匿名对象</p><p>2、特征：只能调用一次</p><p><code>new Student().number();</code></p><h2 id="面向对象特征之一：封装和隐藏"><a href="#面向对象特征之一：封装和隐藏" class="headerlink" title="面向对象特征之一：封装和隐藏"></a>面向对象特征之一：封装和隐藏</h2><p>1、为什么需要封装？封装的作用和含义？<br>我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？<br>我要开车，…<br>2、我们程序设计追求“高内聚，低耦合”。<br>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；<br>低耦合 ：仅对外暴露少量的方法用于使用。<br>3、隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p><p>Java中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：</p><ul><li>隐藏一个类中不需要对外提供的实现细节；</li><li>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；</li><li>便于修改，增强代码的可维护性；</li></ul><p>封装性体现：①类的属性私有化，然后提供公共方法（get、set）②不对外暴露的私有方法③单例模式</p><p>权限修饰符可以修饰类及类的内部结构：属性、方法、构造器、内部类（代码块不可以）</p><h2 id="类的成员之三：构造器"><a href="#类的成员之三：构造器" class="headerlink" title="类的成员之三：构造器"></a>类的成员之三：构造器</h2><p>构造器的特征</p><ul><li>它具有与类相同的名称</li><li>它不声明返回值类型。（与声明为void不同）</li><li>不能被static、final、synchronized、abstract、native修饰，不能有<br>return语句返回值</li></ul><p>构造器的作用：创建对象；给对象进行初始化</p><ul><li>如：Order o &#x3D; new Order(); Person p &#x3D; new Person(“Peter”,15);</li><li>如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。</li></ul><p>根据参数不同，构造器可以分为如下两类：</p><ul><li>隐式无参构造器（系统默认提供）</li><li>显式定义一个或多个构造器（无参、有参）</li></ul><p>注 意：</p><ul><li>Java语言中，每个类都至少有一个构造器</li><li>默认构造器的修饰符与所属类的修饰符一致</li><li>一旦显式定义了构造器，则系统不再提供默认构造器</li><li>一个类可以创建多个重载的构造器</li><li>父类的构造器不可被子类继承</li></ul><h2 id="总结：属性赋值过程"><a href="#总结：属性赋值过程" class="headerlink" title="总结：属性赋值过程"></a>总结：属性赋值过程</h2><p>截止到目前，我们讲到了很多位置都可以对类的属性赋值。现总结这几个位<br>置，并指明赋值的先后顺序。<br>赋值的位置：<br>① 默认初始化<br>② 显式初始化<br>③ 构造器中初始化<br>④ 通过“对象.属性“或“对象.方法”的方式赋值<br>赋值的先后顺序：<br>① - ② - ③ - ④</p><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>JavaBean是一种Java语言写成的可重用组件。所谓javaBean，是指符合如下标准的Java类：</p><ul><li>类是公共的</li><li>有一个无参的公共的构造器</li><li>有属性，且有对应的get、set方法</li></ul><p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/UML%E7%B1%BB%E5%9B%BE.png" alt="img" title="UML类图"></p><h2 id="关键字this"><a href="#关键字this" class="headerlink" title="关键字this"></a>关键字this</h2><p>在Java中，this关键字比较难理解，它的作用和其词义很接近。</p><ul><li>它在方法内部使用，即这个方法所属对象的引用；</li><li>它在构造器内部使用，表示该构造器正在初始化的对象。</li></ul><h3 id="1、this-可以调用类的属性、方法和构造器"><a href="#1、this-可以调用类的属性、方法和构造器" class="headerlink" title="1、this 可以调用类的属性、方法和构造器"></a>1、this 可以调用类的属性、方法和构造器</h3><p>什么时候使用this关键字呢？</p><ul><li>当在方法内需要用到调用该方法的对象时，就用this。</li><li>具体的：我们可以用this来区分属性和局部变量。比如：this.name &#x3D; name;</li></ul><h3 id="2、使用this调用本类的构造器"><a href="#2、使用this调用本类的构造器" class="headerlink" title="2、使用this调用本类的构造器"></a>2、使用this调用本类的构造器</h3><pre><code class="language-java">class Person&#123; // 定义Person类private String name ;private int age ;public Person()&#123; // 无参构造器System.out.println(&quot;新对象实例化&quot;) ;&#125;public Person(String name)&#123;this(); // 调用本类中的无参构造器this.name = name ;&#125;public Person(String name,int age)&#123;this(name) ; // 调用有一个参数的构造器this.age = age;&#125;public String getInfo()&#123;return &quot;姓名：&quot; + name + &quot;，年龄：&quot; + age ;&#125; &#125;</code></pre><p>注意：</p><ul><li>可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！</li><li>明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器</li><li>如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)”</li><li>this(形参列表)”必须声明在类的构造器的首行！</li><li>在类的一个构造器中，最多只能声明一个”this(形参列表)</li></ul><h2 id="package关键字"><a href="#package关键字" class="headerlink" title="package关键字"></a>package关键字</h2><p>1、为了更好实现项目中类的管理，提供包的概念</p><p>2、使用package声明类或接口所属的包，声明在源文件的首航</p><p>3、包，属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）、“见名知意”</p><p>4、每“.”一次，就代表一层文件目录</p><p>补充：</p><ul><li>同一个包下，不能命名同名的接口、类</li><li>不同包下，可以命名同名的接口、类</li></ul><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/jdk%E4%B8%BB%E8%A6%81%E5%8C%85.png" alt="img" title="jdk主要包"></p><h2 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h2><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="img" title="MVC设计模式."></p><h2 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a>import关键字</h2><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/import%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="img" title="import关键字."></p><h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p><strong>为什么要有继承？</strong></p><ul><li>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</li><li>此处的多个类称为子类(派生类)，单独的这个类称为父类(基类或超类)。</li><li>类继承语法规则:<code>class Subclass extends SuperClass&#123; &#125;</code></li></ul><p>作用：</p><ul><li>继承的出现减少了代码冗余，提高了代码的复用性。</li><li>继承的出现，更有利于功能的扩展。</li><li>继承的出现让类与类之间产生了关系，提供了多态的前提。</li></ul><p>注意：不要仅为了获取其他类中某个功能而去继承</p><p>子类继承了父类，就继承了父类的方法和属性（包括私有的方法和属性）。</p><p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。<br>在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。</p><p>关于继承的规则：子类不能直接访问父类中私有的(private)的成员变量和方法。</p><p>Java只支持单继承和多层继承，不允许多重继承：</p><ul><li>一个子类只能有一个父类</li><li>一个父类可以派生出多个子类</li></ul><p><strong>所有类都直接或间接继承了Object类（根父类）</strong></p><ul><li>如果我们没有显示声明一个类的父类，则此类继承于Object类</li><li>意味着该类具有java.lang.Object类声明的功能</li></ul><h2 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h2><p>1、独立完成一遍以上的项目代码</p><p>2、积累完成项目的过程中常见的bug的调试：</p><ul><li>“硬”看，必要时，添加输出语句</li><li>Debug</li></ul><p>3、捋顺思路，强化逻辑</p><p>4、对象、数组等内存结构的解析</p><p>5、遵循编码的规范，标识符的命名规范等</p><p>6、类前、方法前、属性前：文档注释；逻辑步骤：单行、多行注释</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>参考视频：<a href="">https://www.bilibili.com/video/BV1Kb411W75N?p=269&amp;spm_id_from&#x3D;pageDriver&amp;vd_source&#x3D;ccf90130d80396981859cd525be711f0</a></p><p>想知道哪个部分具体情况，就设置断点（如想知道int age &#x3D; …赋值是多少，就在这打断点），然后Debug as</p><p>step over：下一步；step into：进入代码具体执行内容（如进入某个方法内部）；step return：退出代码具体执行内容；resume：执行下一个断点处；jump to frame：回到方法首行</p><p><strong>Debug问题：</strong> 点击step into没有进入方法内部，而是跳到了下一行代码</p><p><strong>解决方法：</strong> 右键Debug as中的Debug Configuration，把Alternate JRE路径（原来可能是jre）改成jdk（如jdk 1.8）</p><p><img src="https://vscode-remote+ssh-002dremote-002bmac.vscode-resource.vscode-cdn.net/Users/michael/Blog/source/images/post/IDE%20Debug%E5%8A%9F%E8%83%BD.png" alt="img" title="IDE Debug功能"></p><h2 id="方法的重写-override-overwrite"><a href="#方法的重写-override-overwrite" class="headerlink" title="方法的重写(override&#x2F;overwrite)"></a>方法的重写(override&#x2F;overwrite)</h2><p>java中overload、override、overwrite的区别：<a href="">https://juejin.cn/post/6997755459260121101</a></p><p>Overload是重载，Override重写(覆盖)，Overwrite java中没有（C++有）</p><p>定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称<br>为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。<br>要求：</p><ol><li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li><li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型<br>比如：父类void子类就只能是void；父类返回值是A类，子类的返回值可以是A类或A的子类；如果父类是基本类型，子类必须相同，如double必须是double</li><li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限<br>子类不能重写父类中声明为private权限的方法</li><li>子类方法抛出的异常不能大于父类被重写方法的异常<br>如父类Exception，子类可以是RuntimeException</li></ol><p><strong>实际开发中，重写可以直接复制父类的方法，改一下方法体就可以；或者直接按IDE提示写</strong></p><p>注意：子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为<br>static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</p><h2 id="关键字—super"><a href="#关键字—super" class="headerlink" title="关键字—super"></a>关键字—super</h2><p><strong>在Java类中使用super来调用父类中的指定操作：</strong></p><ul><li>super可用于访问父类中定义的属性</li><li>super可用于调用父类中定义的成员方法</li><li>super可用于在子类构造器中调用父类的构造器</li></ul><p>通常都是忽略super，当要显式调用父类和子类的同名属性和方法时，需要super和this来区分</p><p>注意：</p><ul><li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</li><li>super的追溯不仅限于直接父类</li><li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li></ul><p><strong>调用父类的构造器</strong></p><ul><li>子类中<strong>所有的构造器</strong>默认都会访问父类中空参数的构造器,在构造器首行，没有this(参数列表)或者super(参数列表)，则默认调用父类无参构造器</li><li>当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能“二选一”，且必须放在构造器的<strong>首行</strong>。</li><li>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错</li><li>在类的多个构造器中，至少有一个构造器使用了super(参数列表)【即调用父类构造器】。一个构造器不是使用super(参数列表)就是使用this(参数列表)</li></ul><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="img" title="this和super的区别"></p><h2 id="子类对象实例化的全过程"><a href="#子类对象实例化的全过程" class="headerlink" title="子类对象实例化的全过程"></a>子类对象实例化的全过程</h2><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B.png" alt="img" title="子类对象实例化的全过程."></p><p><strong>思考：</strong><br>1).为什么super(…)和this(…)调用语句不能同时在一个构造器中出现？<br>2).为什么super(…)或this(…)调用语句只能作为构造器中的第一句出现？</p><p><strong>解答：<a href="">https://www.yisu.com/zixun/276824.html</a></strong></p><pre><code class="language-java">class A &#123;     A()       &#123;            System.out.println(&quot;You call super class non-args constructor!&quot;);         &#125;&#125; class B extends A &#123;      B()      &#123;      //这里，编译器将自动加上 super();      System.out.println(&quot;You call subclass constructor!&quot;);     &#125;    B(String n)    &#123;       super();     this();       //实际就是调用了B()&#123;...&#125;，而在B()&#123;...&#125;中编译器自动加上了       //super();这样就相当于两次调用了super();也就是说对父类进    //行了两次初始化。而在实例化一个对象时，一个构造方法只能调用一次，这说明this和super不能同时存在一个构造方法中。    //同时因为系统没有在第一行发现this()或super()调用，就会自动加上super(),如果没有将this()和super()放在第一行就会产生矛盾。      //因为总有一个super()在第二句上。所以该程序不能通过编译！！！       &#125;&#125;</code></pre><p>结论：也就是说你必须在构造器的第一行放置super或者this构造器，否则编译器会自动地放一个空参数的super构造器的，其他的构造器也可以调用super或者this，调用成一个递归构造链，最后的结果是父类的构造器（可能有多级父类构造器）始终在子类的构造器之前执行，递归的调用父类构造器。无法执行当前的类的构造器。也就不能实例化任何对象，这个类就成为一个无为类。<br>从另外一面说，子类是从父类继承而来，继承了父类的属性和方法，如果在子类中先不完成父类的成员的初始化，则子类无法使用，应为在java中不允许调用没初始化的成员。在构造器中是顺序执行的，也就是说必须在第一行进行父类的初始化。而super能直接完成这个功能。This()通过调用本类中的其他构造器也能完成这个功能。<br>因此，this()或者super()必须放在第一行。</p><p>简而言之：<img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/super%E9%97%AE%E9%A2%98%E7%AE%80%E7%AD%94.png" alt="img" title="super问题简答.png"></p><h2 id="面向对象特征之三：多态性"><a href="#面向对象特征之三：多态性" class="headerlink" title="面向对象特征之三：多态性"></a>面向对象特征之三：多态性</h2><p>多态性，是面向对象中最重要的概念，在Java中的体现：<br>对象的多态性：父类的引用指向子类的对象。</p><p>简单理解：事物的多种形态</p><ul><li>可以直接应用在抽象类和接口上。</li></ul><p><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=280&spm_id_from=pageDriver&vd_source=ccf90130d80396981859cd525be711f0">多态性的比喻举例</a>：三个类：一个父类Person，有eat()方法和walk()方法；一个Person的子类Man，有重写的eat()方法和walk()方法，还有另外的earnmoney()方法；Person的子类Woman，有重写的eat()方法和walk()方法，还有另外的shop()方法。 <code>Person p1 = new Man()，</code>相当于找一个人来（只不过这个人是男性）。p1只能调用eat()和walk()方法，也就是只能做person“人”能做的事。但是eat()和walk()却会执行man重写的方法，也就是找来的人，他做事的方式是男性的方式。</p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%A4%9A%E6%80%81%E6%80%A7.png" alt="img" title="面向对象特征之三：多态性"></p><p>5、对象的多态性：只适用于方法，不适用于属性【调用属性时只会调用父类的属性】</p><p>Object类的clone方法是protected的</p><p>Object类的equals方法的形参是Object类型的【多态性的好处体现，如果没有多态性，给equals方法的参数就只能是Object类型的，就不能是Object的子类如String。多态性能减少方法重载，提高通用性】</p><p><strong>多态性好处的另一体现：</strong></p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%A4%9A%E6%80%81%E6%80%A7%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5.png" alt="img" title="多态性：数据库连接"></p><p>数据库连接可以是mysql，也可以是oracle，体现了多态</p><p>多态性的意义：抽象类和接口的应用，没有多态性，抽象类和接口就不能造对象了，那抽象类和接口就没有意义了</p><h3 id="虚拟方法调用-Virtual-Method-Invocation"><a href="#虚拟方法调用-Virtual-Method-Invocation" class="headerlink" title="虚拟方法调用(Virtual Method Invocation)"></a><strong>虚拟方法调用(Virtual Method Invocation)</strong></h3><p>正常的方法调用</p><pre><code class="language-java">Person e = new Person();e.getInfo();Student e = new Student();e.getInfo();</code></pre><p>虚拟方法调用(多态情况下)<br>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</p><pre><code class="language-java">Person e = new Student();e.getInfo(); //调用Student类的getInfo()方法</code></pre><p>编译时类型和运行时类型<br>编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。——动态绑定【虚拟方法调用的过程】。</p><h3 id="多态是运行时行为"><a href="#多态是运行时行为" class="headerlink" title="多态是运行时行为"></a><strong>多态是运行时行为</strong></h3><p>举例：如下图，随机对象给animal，只有运行后才知道是哪个类型</p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%A4%9A%E6%80%81%E6%98%AF%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A1%8C%E4%B8%BA.png" alt="img" title="多态是运行时行为"></p><h3 id="小结：方法的重载与重写"><a href="#小结：方法的重载与重写" class="headerlink" title="小结：方法的重载与重写"></a>小结：方法的重载与重写</h3><ol><li>二者的定义细节：略</li><li>从编译和运行的角度看：<br>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。<br>所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。<br>引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”<br>重载不体现多态性，重写体现多态性</li></ol><h2 id="向下转型的使用"><a href="#向下转型的使用" class="headerlink" title="向下转型的使用"></a>向下转型的使用</h2><p>当多态不能调用子类特有的属性和方法时，可以向下转型</p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E4%B8%8B%E8%BD%AC%E5%9E%8B.png" alt="img" title="向下转型"></p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AC%E5%9E%8B%E6%AF%94%E8%BE%83.png" alt="img" title="基本数据类型和对象的转型比较"></p><p>强转和基本数据类型的情况一样，都是有风险的。基本数据类型强转可能损失精度，而不同类型强转可能会失败（如Man转成Woman）。</p><h2 id="instanceof关键字的使用"><a href="#instanceof关键字的使用" class="headerlink" title="instanceof关键字的使用"></a>instanceof关键字的使用</h2><p>为了避免向下转型异常，用instanceof进行判断来转型</p><blockquote><p>类B是类A的父类，若a instanceof A返回true，那么a instanceof B也返回true</p></blockquote><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/instanceof%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt="img" title="instanceof的使用"></p><h2 id="转型常见问题"><a href="#转型常见问题" class="headerlink" title="转型常见问题"></a>转型常见问题</h2><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E8%BD%AC%E5%9E%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.png" alt="img" title="转型常见问题"></p><h2 id="多态练习：调用方法和属性"><a href="#多态练习：调用方法和属性" class="headerlink" title="多态练习：调用方法和属性"></a>多态练习：调用方法和属性</h2><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%A4%9A%E6%80%81%E7%BB%83%E4%B9%A0%EF%BC%9A%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7.png" alt="img" title="多态练习：调用方法和属性"></p><p>实际开发不要在子类父类定义同名的属性</p><h3 id="重写方法小细节"><a href="#重写方法小细节" class="headerlink" title="重写方法小细节"></a>重写方法小细节</h3><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%86%E8%8A%82.png" alt="img" title="重写方法小细节"></p><p>int… 和 int[] 在形参中视为一样</p><p>如果Sub1里再来个 <code>add(int a, int b, int c)</code>，那调用时还是调用 <code>add(int a, int[] arr)</code>方法，因为该方法才是重写的方法。</p><p>但如果main方法改为下图形式，那就是调用 <code>add(int a, int b, int c)，因为确定形参优先级大于不确定形参</code></p><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>object类的功能（属性、</p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%A4%9A%E6%80%81%E6%80%A7%E7%BB%83%E4%B9%A0main%E6%96%B9%E6%B3%95.png" alt="img" title="多态性练习main方法"></p><p>clone()、equals()、toString()…</p><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><p><strong>“&#x3D;&#x3D;”运算符的使用</strong></p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E2%80%9C==%E2%80%9D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt="img" title="“&#x3D;&#x3D;”运算符的使用"></p><p>基本数据类型出了boolean都可以用“&#x3D;&#x3D;”运算符互相比较，且只看两个变量保存的数据是否相同，如 <code>int i = 10; char c = 10;</code>，那么 <code>i==c</code></p><p>但引用类型使用“&#x3D;&#x3D;”运算符时，两类型必须一致，否则编译不通过</p><p><strong>equals()方法的使用</strong></p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/equals()%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt="img" title="equals()方法的使用"></p><p>开发中常常需要重写的equals方法来达到自己想要的效果，写法可以参考String的equals方法。实际开发用IDE的功能重写equals，IDE往往写的比自己写的要全面。</p><p><a href="https://blog.csdn.net/weixin_34055346/article/details/113002024?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-3-113002024-null-null.pc_agg_new_rank&utm_term=equals%E6%94%BE%E5%89%8D%E9%9D%A2&spm=1000.2123.3001.4430">null.equals会报空指针异常</a></p><p><strong>重写equals()方法的原则</strong></p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E9%87%8D%E5%86%99equals()%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E5%88%99.png" alt="img" title="重写equals()方法的原则"></p><p><strong>重写equals时的小细节</strong>【String类型要用equals而不是&#x3D;&#x3D;】<a href="https://www.bilibili.com/video/BV1Kb411W75N?p=299&spm_id_from=pageDriver&vd_source=ccf90130d80396981859cd525be711f0">8:10</a></p><p>因为 <code>String a1 = &quot;AA&quot;; String a2 = &quot;AA&quot;; a1 == a2//true</code>。由于”AA”存放在方法区常量池中，由于赋值a2时，常量池中已有该值，因此a2会直接复用指向。但如果 <code>a2 = new String(&quot;AA&quot;)</code>，那么 <code>a1 == a2//false</code>。因此比较String还是要equals。</p><p>只要基本数据类型就&#x3D;&#x3D;，引用类型就equals。</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><pre><code class="language-java">Integer in1 = new Integer(&quot;123&quot;)//okInteger in2 = new Integer(&quot;123abc&quot;)//报异常Boolean b2 = new Boolean(&quot;trUe&quot;)//okBoolean b3 = new Boolean(&quot;true123&quot;)//false，只要不是true，其他全是false</code></pre><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%8C%85%E8%A3%85%E7%B1%BB.png" alt="img" title="包装类"></p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/static%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="image-20220802210803095"></p><h3 id="static修饰变量"><a href="#static修饰变量" class="headerlink" title="static修饰变量"></a>static修饰变量</h3><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/static%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F.png" alt="image-20220802211749235"></p><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/static%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F2.png" alt="image-20220802214259242"></p><p>static修饰变量，打个比方就像书房的书，改动都会影响书，调用时都会调用同一本书。非static变量就像每间卧室的床，每个对象都独立拥有自己的床，互不影响。</p><p>实例对象加载晚于对象创建，静态对象加载早于对象创建。</p><h3 id="类变量与实例变量内存解析"><a href="#类变量与实例变量内存解析" class="headerlink" title="类变量与实例变量内存解析"></a>类变量与实例变量内存解析</h3><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E7%B1%BB%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.png" alt="image-20220802215043089"></p><h3 id="static修饰方法"><a href="#static修饰方法" class="headerlink" title="static修饰方法"></a>static修饰方法</h3><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/static%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95.png" alt="image-20220802221517311"></p><h3 id="开发如何确定是否要用static"><a href="#开发如何确定是否要用static" class="headerlink" title="开发如何确定是否要用static"></a>开发如何确定是否要用static</h3><p><img src="/../images/post/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%98%AF%E5%90%A6%E8%A6%81%E7%94%A8static.png" alt="image-20220802222757167"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>达芬奇笔记</title>
      <link href="/2022/06/29/%E8%BE%BE%E8%8A%AC%E5%A5%87%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/29/%E8%BE%BE%E8%8A%AC%E5%A5%87%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="达芬奇导入到Pr、AE"><a href="#达芬奇导入到Pr、AE" class="headerlink" title="达芬奇导入到Pr、AE"></a>达芬奇导入到Pr、AE</h2><h3 id="达芬奇导入到Pr"><a href="#达芬奇导入到Pr" class="headerlink" title="达芬奇导入到Pr"></a>达芬奇导入到Pr</h3><p><strong>达芬奇交付面板选择Premier XML，选择mp4 H.264，然后渲染导出。在Pr点击导入，选择达芬奇导出的XML文件，待全部导入后双击导入的XML文件，时间轴上就有素材了。</strong></p><h3 id="达芬奇导入到AE"><a href="#达芬奇导入到AE" class="headerlink" title="达芬奇导入到AE"></a>达芬奇导入到AE</h3><p><strong>达芬奇交付面板选择自定义，选择多个单独片段，勾选单独文件名，然后导出就可以了。</strong></p><p><strong><a href="%5Bhttps://www.bilibili.com/video/BV1rP4y1g7gr?spm_id_from=333.880.my_history.page.click&&vd_source=ccf90130d80396981859cd525be711f0%5D(https://www.bilibili.com/video/BV1rP4y1g7gr?spm_id_from=333.880.my_history.page.click&vd_source=ccf90130d80396981859cd525be711f0)">参考教程</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 达芬奇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础编程笔记</title>
      <link href="/2022/06/27/Java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/27/Java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、代码简洁之道"><a href="#一、代码简洁之道" class="headerlink" title="一、代码简洁之道"></a>一、代码简洁之道</h2><p>整理人：尚硅谷 - 宋红康</p><p>第2章 有意义的命名<br>2.1 介绍<br>软件中随处可见命名。我们给变量、函数、参数、类和包命名。我们给源代码及源代码所在目录命名。<br>这么多命名要做，不妨做好它。下文列出了取个好名字的几条简单规则。</p><p>2.2 名副其实,见名知意<br>     变量名太随意，haha、list1、ok、theList 这些都没啥意义</p><p>2.3 避免误导<br>     包含List、import、java等类名、关键字或特殊字；<br>     字母o与数字0，字母l与数字1等<br>     提防使用不同之处较小的名称。比如：XYZControllerForEfficientHandlingOfStrings与XYZControllerForEfficientStorageOfStrings</p><p>2.4 做有意义的区分<br>     反面教材，变量名：a1、a2、a3<br>     避免冗余，不要出现Variable、表字段中避免出现table、字符串避免出现nameString，直接name就行，知道是字符串类型<br>     再比如：定义了两个类：Customer类和CustomerObject类，如何区分？<br>     定义了三个方法：getActiveAccount()、getActiveAccounts()、getActiveAccountInfo()，如何区分？</p><p>2.5 使用读得出来的名称<br>     不要使用自己拼凑出来的单词，比如：xsxm(学生姓名)；genymdhms(生成日期，年、月、日、时、分、秒)<br>     所谓的驼峰命名法，尽量使用完整的单词</p><p>2.6 使用可搜索的名称<br>     一些常量，最好不直接使用数字，而指定一个变量名，这个变量名可以便于搜索到.<br>     比如：找MAX_CLASSES_PER_STUDENT很容易，但想找数字7就麻烦了。</p><p>2.7 避免使用编码<br>     2.7.1 匈牙利语标记法<br>           即变量名表明该变量数据类型的小写字母开始。例如，szCmdLine的前缀sz表示“以零结束的字符串”。<br>     2.7.2 成员前缀<br>          避免使用前缀，但是Android中一个比较好的喜欢用m表示私有等，个人感觉比较好<br>     2.7.3 接口和实现<br>          作者不喜欢把接口使用I来开头，实现也希望只是在后面添加Imp</p><p>2.8 避免思维映射<br>     比如传统上惯用单字母名称做循环计数器。所以就不要给一些非计数器的变量命名为：i、j、k等</p><p>2.9  类名<br>     类名与对象名应该是名词与名词短语。如Customer、WikiPage、Account和AddressParser。避免使用Data或Info这样的类名。<br>     不能使用动词。比如：Manage、Process</p><p>2.10 方法名<br>     方法名应当是动词或者动词短语。如postPayment、deletePage或save</p><p>2.11 别扮可爱<br>     有的变量名叫haha、banana<br>     别用eatMyShorts()表示abort()</p><p>2.12 每个概念对应一个词<br>     项目中同时出现controllers与managers，为什么不统一使用其中一种？<br>     对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。</p><p>2.13 别用双关语<br>     有时可能使用add并不合适，比例insert、append。add表示完整的新添加的含义。</p><p>2.14 使用解决方案领域名称<br>     看代码的都是程序员，所以尽量用那些计算机科学术语、算法名、模式名、数学术语，<br>     依据问题所涉领域来命名不算是聪明的做法。</p><p>2.15 使用源自所涉问题领域的名称<br>     如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称吧。<br>     至少，负责维护代码的程序员就能去请教领域专家了。</p><p>2.16 添加有意义的语境<br>     可以把相关的变量放到一个类中，使用这个类来表明语境。</p><p>2.17 不要添加没用的语境<br>     名字中带有项目的缩写，这样完全没有必要。比如有一个名为“加油站豪华版”（Gas Station Deluxe）的项目，<br>     在其中给每个类添加GSD前缀就不是什么好策略。</p><p>2.18 最后的话<br>     取好名字最难的地方在于需要良好的描述技巧和共有文化背景。</p><h2 id="二、流程控制"><a href="#二、流程控制" class="headerlink" title="二、流程控制"></a>二、流程控制</h2><h3 id="1、分支结构"><a href="#1、分支结构" class="headerlink" title="1、分支结构"></a>1、分支结构</h3><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。<br>  当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构<br>  末尾结束为止。<br>② switch结构中的表达式，只能是如下的6种数据类型之一：<br>   byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)<br>③ case 之后只能声明常量。不能声明范围。<br>④ default:相当于if-else结构中的else. default结构是可选的，而且位置是灵活的。</p><h3 id="2、循环结构"><a href="#2、循环结构" class="headerlink" title="2、循环结构"></a>2、循环结构</h3><p>1.do-while循环至少会执行一次循环体！<br>2.开发中，使用for和while更多一些。较少使用do-while</p><p>补充:衡量一个功能代码的优劣：<br>1.正确性<br>2.可读性<br>3.健壮性<br>4.高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）</p><h2 id="3、Scanner类的使用"><a href="#3、Scanner类的使用" class="headerlink" title="3、Scanner类的使用"></a>3、Scanner类的使用</h2><p>如何从键盘获取不同类型的变量：需要使用Scanner类</p><p>具体实现步骤：<br>1.导包：import java.util.Scanner;<br>2.Scanner的实例化:Scanner scan &#x3D; new Scanner(System.in);<br>3.调用Scanner类的相关方法（next() &#x2F; nextXxx()），来获取指定类型的变量</p><p>注意：<br>需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchException<br>导致程序终止。</p><pre><code class="language-java">//1.导包：import java.util.Scanner;import java.util.Scanner;class ScannerTest&#123;public static void main(String[] args)&#123;//2.Scanner的实例化Scanner scan = new Scanner(System.in);//3.调用Scanner类的相关方法System.out.println(&quot;请输入你的姓名：&quot;);String name = scan.next();System.out.println(name);System.out.println(&quot;请输入你的芳龄：&quot;);int age = scan.nextInt();System.out.println(age);System.out.println(&quot;请输入你的体重：&quot;);double weight = scan.nextDouble();System.out.println(weight);System.out.println(&quot;你是否相中我了呢？(true/false)&quot;);boolean isLove = scan.nextBoolean();System.out.println(isLove);//对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串System.out.println(&quot;请输入你的性别：(男/女)&quot;);String gender = scan.next();//&quot;男&quot;char genderChar = gender.charAt(0);//获取索引为0位置上的字符System.out.println(genderChar);&#125;&#125;</code></pre><h2 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h2><p>1.数据与数据之间的逻辑关系：集合、一对一、一对多、多对多<br>2.数据的存储结构：<br>线性表：顺序表（比如：数组）、链表、栈、队列<br>树形结构：二叉树<br>图形结构：</p><p>算法：排序算法、搜索算法..</p><p>声明方法：</p><pre><code class="language-java">int num;//声明num = 10;//初始化int id = 1001;//声明 + 初始化qint[] ids;//声明//1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行ids = new int[]&#123;1001,1002,1003,1004&#125;;//1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行String[] names = new String[5];int[] arr4 = &#123;1,2,3,4,5&#125;;//类型推断</code></pre><p>3.数组的属性：length</p><pre><code class="language-java">System.out.println(names.length);</code></pre><p>说明：1、数组一旦初始化，其长度就是确定的。arr.length；2、数组长度一旦确定，就不可修改。</p><p>4.一维数组元素的默认初始化值</p><ul><li>数组元素是整型：0</li><li>数组元素是浮点型：0.0</li><li>数组元素是char型：0或’\u0000’，而非’0’</li><li>数组元素是boolean型：false</li><li>数组元素是引用数据类型：null</li></ul><p>数组内存解析</p><p><img src="/images/post/shuzuneicun.png" alt="shuzuneicun"></p><p>5.二维数组</p><pre><code>数组元素的默认初始化值</code></pre><ul><li>针对于初始化方式一：比如：int[][] arr &#x3D; new int[4][3];</li><li>外层元素的初始化值为：地址值</li><li>内层元素的初始化值为：与一维数组初始化情况相同</li><li></li><li>针对于初始化方式二：比如：int[][] arr &#x3D; new int[4][];</li><li>外层元素的初始化值为：null</li><li>内层元素的初始化值为：不能调用，否则报错。</li></ul><p>二维数组内存解析</p><p><img src="/images/post/shuzuneicun2.png" alt="shuzuneicun"></p><p>数组小项目：杨辉三角、回形数</p><h3 id="数组常见算法"><a href="#数组常见算法" class="headerlink" title="数组常见算法"></a>数组常见算法</h3><p><strong>…</strong></p><h3 id="Arrays工具类的使用"><a href="#Arrays工具类的使用" class="headerlink" title="Arrays工具类的使用"></a>Arrays工具类的使用</h3><p>常见工具类：sort、 binarysearch、equals、fill、toString</p><h3 id="数组的常见异常"><a href="#数组的常见异常" class="headerlink" title="数组的常见异常"></a>数组的常见异常</h3><p><strong>1.数组角标越界异常：ArrayIndexOutOfBoundsException</strong></p><p>①<code>arr[-2]</code>  ②<code>arr[&quot;&gt;arr.length&quot;]</code></p><p><strong>2.空指针异常：NullPointerException</strong></p><p>①<code>arr=null</code>  ②<code>int[][] arr = new int[4][]</code></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记</title>
      <link href="/2022/06/27/Java%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/27/Java%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><a href="https://zhidao.baidu.com/question/153225511.html">Java中遍历Map对象的4种方法：</a></p><blockquote><p>1、通过Map.entrySet遍历key和value，在for-each循环中使用entries来遍历.推荐，尤其是容回量大时。</p><p><a href="https://github.com/hiki11/Java-Notes/blob/master/image/9922720e0cf3d7ca112bc0ccff1fbe096a63a9af.png"><img src="https://github.com/hiki11/Java-Notes/raw/master/image/9922720e0cf3d7ca112bc0ccff1fbe096a63a9af.png" alt="img"></a></p><p>2、通过Map.keySet遍历key，通过键找答值value遍历（效率低）,普遍使用，二次取值。</p><p><a href="https://github.com/hiki11/Java-Notes/blob/master/image/9d82d158ccbf6c81525bd252b13eb13533fa4018.png"><img src="https://github.com/hiki11/Java-Notes/raw/master/image/9d82d158ccbf6c81525bd252b13eb13533fa4018.png" alt="img"></a></p><p>3、如果只需要map中的键或者值，你可以通过Map.keySet或Map.values来实现遍历，而不是用entrySet。在for-each循环中遍历keys或values。</p><p><a href="https://github.com/hiki11/Java-Notes/blob/master/image/5bafa40f4bfbfbedb014c8c575f0f736afc31f3e.png"><img src="https://github.com/hiki11/Java-Notes/raw/master/image/5bafa40f4bfbfbedb014c8c575f0f736afc31f3e.png" alt="img"></a></p><p>4、通过Map.entrySet使用iterator遍历key和value。</p><p><a href="https://github.com/hiki11/Java-Notes/blob/master/image/2cf5e0fe9925bc319ef1ff2253df8db1ca1370d8.png"><img src="https://github.com/hiki11/Java-Notes/raw/master/image/2cf5e0fe9925bc319ef1ff2253df8db1ca1370d8.png" alt="img"></a></p><p>扩展资料：</p><p>关于JAVA的遍历知识补充：</p><p>1、list和set集合都实现了Iterable接口，所以他们的实现类可以使用迭代器遍历，map集合未实现该接口，若要使用迭代器循环遍历，需要借助set集合。</p><p>2、使用EntrySet 遍历，效率更高。</p></blockquote><p>未完成</p><p><a href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&tn=84053098_3_dg&wd=java%200:0:0:0:0:0:0:1&oq=Mac%2520java%25200%253A0%253A0%253A0%253A0%253A0%253A0%253A1&rsv_pq=f570dd040007ae76&rsv_t=78bcCPLSyVhbNsRk8Eliizxnb/4TVtsp9RYv1AWH0gI0yu4ixoJ8YwxyQjS+UF7w59sp8g&rqlang=cn&rsv_enter=1&rsv_dl=tb&inputT=252&rsv_sug3=13&rsv_sug2=0&rsv_sug4=9327&bs=Mac%20java%200:0:0:0:0:0:0:1&rsv_jmp=fail">Java 0:0:0:0</a>未添加</p><p><a href="https://blog.csdn.net/zhengwangzw/article/details/104889549?utm_medium=distribute.pc_category.none-task-blog-hot-10&depth_1-utm_source=distribute.pc_category.none-task-blog-hot-10&request_id=">一个HashMap跟面试官扯了半个小时</a> <strong>安琪拉</strong></p><blockquote><p>HashMap的内部数据结构，JDK1.8版本的，内部使用数组 + 链表红黑树：</p><p><a href="https://github.com/hiki11/Java-Notes/blob/master/image/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS85ZDkyZGRkYS1lZmRiLTRmZjctYTlmYi00MTFjMTY5MzNkYmMucG5n.png"><img src="https://github.com/hiki11/Java-Notes/raw/master/image/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS85ZDkyZGRkYS1lZmRiLTRmZjctYTlmYi00MTFjMTY5MzNkYmMucG5n.png" alt="img"></a></p><p>HashMap的数据插入原理：</p><p><a href="https://github.com/hiki11/Java-Notes/blob/master/image/2020031712385760.png"><img src="https://github.com/hiki11/Java-Notes/raw/master/image/2020031712385760.png" alt="img"></a></p><ol><li>判断数组是否为空，为空进行初始化;</li><li>不为空，计算 k 的 hash 值，通过 <code>(n - 1) &amp; hash</code>计算应当存放在数组中的下标 index;</li><li>查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；</li><li>存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据(onlyIfAbsent为false)；</li><li>如果不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；(如果当前节点是树型节点证明当前已经是红黑树了)</li><li>如果不是树型节点，创建普通Node加入链表中；判断链表长度是否大于 8并且数组长度大于64， 大于的话链表转换为红黑树；</li><li>插入完成之后判断当前节点数是否大于阈值，如果大于开始扩容为原数组的二倍。</li></ol><p>HashMap怎么设定初始容量大小：一般如果 <code>new HashMap()</code> 不传值，默认大小是16，负载因子是0.75， 如果自己传入初始大小k，初始化大小为 大于k的 2的整数次方，例如如果传10，大小为16。（补充说明:实现代码如下）</p><pre><code class="language-java">static final int tableSizeFor(int cap) &#123;  int n = cap - 1;  n |= n &gt;&gt;&gt; 1;  n |= n &gt;&gt;&gt; 2;  n |= n &gt;&gt;&gt; 4;  n |= n &gt;&gt;&gt; 8;  n |= n &gt;&gt;&gt; 16;  return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;</code></pre><p>HashMap的哈希函数：hash函数是先拿到 key 的hashcode，是一个32位的int值，然后让hashcode的高16位和低16位进行异或操作。也叫扰动函数，这么设计有二点原因：</p><ol><li>一定要尽可能降低hash碰撞，越分散越好；</li><li>算法一定要尽可能高效，因为这是高频操作, 因此采用位运算；</li></ol><p>hashcode的高16位和低16位异或能降低hash碰撞的原因，hash函数能不能直接用key的hashcode：</p></blockquote><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><a href="https://blog.csdn.net/qq_34375473/article/details/81487803">final关键字：</a></p><blockquote><p>final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。</p></blockquote><h3 id="Java数组的三种打印方式"><a href="#Java数组的三种打印方式" class="headerlink" title="Java数组的三种打印方式"></a><a href="https://blog.csdn.net/chenkaibsw/article/details/78989459">Java数组的三种打印方式</a></h3><blockquote><p><strong>1.数组的输出的三种方式</strong></p><p><strong>一维数组：</strong></p><p>定义一个数组 int[] array &#x3D; {1,2,3,4,5};</p><p>（1）传统的for循环方式</p><pre><code class="language-java">for(int i=0;i&lt;array.length;i++)&#123;      System.out.println(array[i]);&#125;</code></pre><p>（2）for each循环</p><pre><code class="language-java">for(int a:array)    System.out.println(a);</code></pre><p>3）利用Array类中的toString方法</p><p>调用Array.toString(a)，返回一个包含数组元素的字符串，这些元素被放置在括号内，并用逗号分开</p><pre><code class="language-java">int[] array = &#123;1,2,3,4,5&#125;;System.out.println(Arrays.toString(array));</code></pre><p>System.out.println(array);打印是的是数组的首地址。</p><p>二维的方法相似，多维数组被解读为”数组的数组”。</p></blockquote><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="Java-Web基础篇之浅谈JVM"><a href="#Java-Web基础篇之浅谈JVM" class="headerlink" title="Java Web基础篇之浅谈JVM"></a><a href="https://blog.csdn.net/zangdaiyang1991/article/details/90749676">Java Web基础篇之浅谈JVM</a></h3><blockquote><p>JVM(Java Virtual Machine)：整个java实现跨平台的最核心的部分，能够运行以Java语言写的程序。</p><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p><p>Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</p><h2 id="JVM体系结构与运行原理"><a href="#JVM体系结构与运行原理" class="headerlink" title="JVM体系结构与运行原理"></a>JVM体系结构与运行原理</h2><p>Java语言写的源程序通过Java编译器，编译成与平台无关的‘字节码程序’(.class文件，也就是0，1二进制程序)，然后在OS之上的Java解释器中解释执行。</p><p><a href="https://github.com/hiki11/Java-Notes/blob/master/Users/michael/Documents/Notes/Java/image/20160704103920750.png"><img src="https://github.com/hiki11/Java-Notes/raw/master/Users/michael/Documents/Notes/Java/image/20160704103920750.png" alt="img"></a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ae笔记</title>
      <link href="/2022/06/26/Ae%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/26/Ae%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Ae常用快捷键"><a href="#Ae常用快捷键" class="headerlink" title="Ae常用快捷键"></a>Ae常用快捷键</h2><p>锚点：Y</p><p>位置：P</p><p>透明度：T</p><p>缩放：S</p><p>遮罩：M</p><p>遮罩羽化：F</p><p>复制：Ctrl+D</p><p>裁剪：Ctrl+Shift+D</p><p>渲染合成：Ctrl+M</p><p>导入素材：Ctrl+I</p><p>删除所选图层所有效果：Ctrl+Shift+E</p><p>新建纯色图层：Ctrl+Y</p><p>新建调整图层：Ctrl+Alt+Y</p><p>新建文字图层：Ctrl+Shift+T</p><p>关键帧添加缓动：F9</p><p>关键帧添加缓入：Shift+F9</p><p>编辑关键帧速率：Ctrl+Shift+K</p><p>文字工具：Ctrl+T</p><p>新建合成：Ctrl+N</p><p>根据所选图层创建预合成：Ctrl+Shift+C</p><p>设置合成参数：Ctrl+K</p><h2 id="新建合成和参数设置"><a href="#新建合成和参数设置" class="headerlink" title="新建合成和参数设置"></a>新建合成和参数设置</h2><p>预设选项：<br>地区标准制式：</p><ul><li>NTSC（29.97fps）：美&#x2F;日&#x2F;韩&#x2F;中国台湾地区</li><li>PAL（25fps）：中国&#x2F;欧洲&#x2F;印度等地区</li></ul><p>电影标准：24fps（影视行业通用）</p><p>像素长宽比：推荐「方形像素」（适配数字媒体）</p><p>帧速率：常规选择：25fps（PAL标准）</p><p>分辨率：始终选择「完整」（最高画质输出）</p><p><strong>设置原则建议</strong></p><p>前期设置：拍摄设备参数→项目参数→输出参数保持一致</p><p>后期调整：优先通过合成设置修改，避免直接缩放图层</p><p><a href="www.bilibili.com/video/BV1k8411b7Xp">【ae教程】新建合成和参数设置，关于AE合成参数的设置详解</a></p><h2 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h2><p>ae是点跟踪器，mocha是面跟踪器</p><h3 id="Ae跟踪"><a href="#Ae跟踪" class="headerlink" title="Ae跟踪"></a>Ae跟踪</h3><p>打开跟踪器面板，点击跟踪运动，选择各个参数使用。</p><p>ae的跟踪点（锚点）对跟踪没有影响，而两个框才是关键。内部的是目标框，外部的是搜索框。</p><p><img src="/../images/post/Ae%E7%AC%94%E8%AE%B0/1705214916532.png" alt="1705214916532"></p><h3 id="mocha跟踪"><a href="#mocha跟踪" class="headerlink" title="mocha跟踪"></a>mocha跟踪</h3><p>分析用户给定的样条区域，在整个画面寻找匹配的区域。</p><p><img src="/../images/post/Ae%E7%AC%94%E8%AE%B0/1705215218193.png" alt="1705215218193"></p><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1QE411Y74H/?p=7">学AE跟踪这套中文教程就够了</a></p><p><a href="https://www.bilibili.com/video/BV1qa4y1H7Wf">『科普向』凭什么Mocha比AE自带跟踪器好用│feat. 运动跟踪技术</a></p><h2 id="Ae摄像头说明"><a href="#Ae摄像头说明" class="headerlink" title="Ae摄像头说明"></a>Ae摄像头说明</h2><p><strong>光圈</strong></p><p>景深是由镜头光圈的大小来控制的——说白了就是让光线进入的孔的大小。孔越大，景深越小——物体越少。光圈很小时，景深就很大——换句话说，一切都在焦点上。摄影师以 F 值来测量光圈，大多数真实相机镜头的 F 值范围约为 F4 到 F22，软件中的虚拟相机可以轻松实现小于 1 的光圈值。</p><p>在现实世界中拍照时，摄影师的选择受到可用光线量的限制。使用软件中的虚拟相机，不存在曝光和光线问题，因此可以设置光圈控制来创建所需的景深，而不必担心可用的光线量。</p><p>基本上——光圈越大，图像越模糊。</p><p><strong>焦距</strong></p><p>After Effects 遵循数十年的传统，使用 35mm 摄影作为镜头预设的参考</p><p>对35mm画幅，通常认为40—60mm之间的镜头都是标准镜头【35 毫米胶片一直是静态摄影中使用的主要胶片格式】【在胶片时代相机成像是通过胶片来成像的，而在数码时代相机成像是通过感光元件来成像的；正如胶卷有很多种尺寸一样，数码时代的不同画幅指的是各种大小的传感器】</p><p>普通广角镜头焦距一般为24—38mm，超广角镜头焦距为13—20mm</p><p>长焦镜头通常指焦距约在80—300mm之间的镜头</p><p>35毫米和28毫米镜头是流行的广角镜头。而焦距在80至105毫米之间的镜头通常被称为“人像”镜头，因为它们很受拍摄人像的摄影师的欢迎，因为它们使脸部稍微变平，使人看起来更有魅力。</p><p><a href="%E7%9B%B8%E6%9C%BA%E5%9F%BA%E6%9C%AC%E9%95%9C%E5%A4%B4%E7%84%A6%E8%B7%9D%E4%B8%8E%E5%BD%B1%E5%83%8F%E5%A4%A7%E5%B0%8F%E5%85%B3%E7%B3%BB.md">相机基本镜头焦距与影像大小关系</a></p><a href="/2023/12/28/After-Effects-%E7%9B%B8%E6%9C%BA%E5%86%85%E9%83%A8/" title="After Effects 相机内部">After Effects 相机内部</a><p>画幅相关解释：<a href="http://www.360doc.com/content/12/0121/07/61035258_1096221963.shtml">相机基础知识：全画幅、半画幅、中画幅是什么？</a></p><h3 id="Ae摄像头快捷键"><a href="#Ae摄像头快捷键" class="headerlink" title="Ae摄像头快捷键"></a>Ae摄像头快捷键</h3><p>在Ae监视器中，选择统一摄像机工具，此时点击Ae监视器。左键旋转，中间移动，右键缩放</p><h3 id="跟踪摄像机"><a href="#跟踪摄像机" class="headerlink" title="跟踪摄像机"></a>跟踪摄像机</h3><h4 id="跟踪绑定方式"><a href="#跟踪绑定方式" class="headerlink" title="跟踪绑定方式"></a>跟踪绑定方式</h4><p>在建立了已跟踪的物体（如空白、文字和固态层等）的基础上，有两种方法：<br>方法1、复制已跟踪的物体的位置属性到要绑定的物体。</p><p>方法2、重置要绑定的物体，然后按住shift链接父级到已跟踪的物体。</p><p>按住【Shift】键建立父子级时，子级会自动匹配父级属性参数。</p><p><a href="https://www.bilibili.com/video/BV1AS4y127AQ">AE | 教程答疑 发光文字跟踪 演示saber文字及发光文字的跟踪</a></p><h3 id="摄像机反求"><a href="#摄像机反求" class="headerlink" title="摄像机反求"></a>摄像机反求</h3><p>第一步在窗口找到跟踪面板，打开跟踪摄像机（track camera）。看需求是否要打开细节分析（detailed analysis），开启会精准但速度会慢五六倍。解析完成后会出现很多点，绿色表示高质量，红色就表示追踪质量不太好。可以调大标靶来更好判断跟踪平面。选择几个质量好的点形成平面，在平面内随意移动红色标靶来确认平面质量。确认好后右键平面，创建“阴影层、摄像机和灯光”。根据地面调整阴影层大小，选择几个绿点建立文字层。</p><p><a href="https://www.bilibili.com/video/BV12W411a74P">【CGtube教程】AE摄像机反求详细教程</a></p><h2 id="Element3D"><a href="#Element3D" class="headerlink" title="Element3D"></a>Element3D</h2><h3 id="模型导入方式"><a href="#模型导入方式" class="headerlink" title="模型导入方式"></a>模型导入方式</h3><p><strong>问题：</strong></p><p>有时候勾上“使用自动法线”会导致ae崩溃。</p><h3 id="e3d-跟踪摄像机"><a href="#e3d-跟踪摄像机" class="headerlink" title="e3d 跟踪摄像机"></a>e3d 跟踪摄像机</h3><p>摄像机解析​​：添加“跟踪摄像机”效果，解析实景视频，选择合适平面创建空白层和摄像机。</p><p><a href="https://www.bilibili.com/video/BV1st411r78k/?vd_source=ccf90130d80396981859cd525be711f0">【AE】E3D实景三维文字</a></p><p><a href="https://www.bilibili.com/video/BV12x41157dC?p=13&vd_source=ccf90130d80396981859cd525be711f0">https://www.bilibili.com/video/BV12x41157dC?p=13&amp;vd_source=ccf90130d80396981859cd525be711f0</a></p><h3 id="e3d模拟光照反射"><a href="#e3d模拟光照反射" class="headerlink" title="e3d模拟光照反射"></a>e3d模拟光照反射</h3><p><a href="https://www.bilibili.com/video/BV1u2421F7tB/?spm_id_from=333.999.0.0&vd_source=ccf90130d80396981859cd525be711f0">https://www.bilibili.com/video/BV1u2421F7tB/?spm_id_from=333.999.0.0&amp;vd_source=ccf90130d80396981859cd525be711f0</a></p><h2 id="Ae局部发光特效"><a href="#Ae局部发光特效" class="headerlink" title="Ae局部发光特效"></a>Ae局部发光特效</h2><p>首先选择发光部分，插件是BCC Line Color Key，复制要发光的素材，使用效果。设置Key Color为要发光的部分，OutPut设置为Composite-Inv Alpha，其余参数适当调节。【本质是色键alpha反转】。<br>Deep Glow效果设置发光效果，参数适当调节。</p><p><a href="https://www.bilibili.com/video/BV1BL4y1c7dq?vd_source=ccf90130d80396981859cd525be711f0">【AE教程】局部发光&#x2F;变色</a></p><h2 id="特效制作"><a href="#特效制作" class="headerlink" title="特效制作"></a>特效制作</h2><h3 id="Ae樱花粒子特效"><a href="#Ae樱花粒子特效" class="headerlink" title="Ae樱花粒子特效"></a>Ae樱花粒子特效</h3><p><a href="https://www.bilibili.com/video/BV1ts411e79N?vd_source=ccf90130d80396981859cd525be711f0">参考教程</a></p><p>导入樱花粒子的图片素材（png格式），预合成粒子素材，新建固态层“粒子特效”，为固态层添加Particle特效。发射器类型（Emitter Type）改为“盒（Box）”，更改发射器尺寸（Emitter Size XYZ）大致1640、800、3200，调整发射器位置。</p><p>粒子类型选择“Textured Polygon Fill”（教程旧版是选择Sprite），材质（Texture）→图层（Layer）选择预合成的粒子素材，更改粒子大小。</p><p>打开物理选项（Physics），重力（Gravity）改为10。打开气（Air）改变风向，XYZ大致为200、250、20。打开扰乱场（Air下的Turbulence Field）更改“影响位置”（Affect Position）参数。更改生命期不透明度（Opacity over Life）渐变消失，如下：</p><p><img src="/images%5Cquxian.png" alt="quxian"></p><p>生命期尺寸也调整为如上曲线。适当延长粒子生命（Life[sec]）如9 sec。打开旋转（Rotation）适当更改如Rotation Speed Z 0.4。</p><p>预览效果，更改粒子特效层的图层混合为Color Dodge【颜色减淡】。适当修改物理时间因素（Physics Time Factor）如0.5，来延迟樱花下落。可以添加发光效果。</p><h3 id="Ae32位色深光带效果"><a href="#Ae32位色深光带效果" class="headerlink" title="Ae32位色深光带效果"></a>Ae32位色深光带效果</h3><p><a href="https://www.bilibili.com/video/BV1Vt411d7or?p=154&vd_source=ccf90130d80396981859cd525be711f0">https://www.bilibili.com/video/BV1Vt411d7or?p=154&amp;vd_source=ccf90130d80396981859cd525be711f0</a></p><p>在32位色深下，复制一层视频【8位色深】，然后上层视频调整色阶，“Input Black”调整为0.95，视频混合模式改为add。</p><h3 id="文字拆散文本效果"><a href="#文字拆散文本效果" class="headerlink" title="文字拆散文本效果"></a>文字拆散文本效果</h3><p><a href="https://www.bilibili.com/video/BV1nD4y1m7o9/?vd_source=ccf90130d80396981859cd525be711f0">参考教程</a></p><p>新建文本图层，打一段文本。然后新建纯色层，e3d选择文本，挤出后返回。选择e3d效果的群组，然后启动粒子效果中的多边形，调整打散效果即可。</p><h3 id="闪电环绕人物模型"><a href="#闪电环绕人物模型" class="headerlink" title="闪电环绕人物模型"></a>闪电环绕人物模型</h3><p><a href="https://www.bilibili.com/video/BV1Nu4y1q7Jf/?vd_source=ccf90130d80396981859cd525be711f0">参考教程</a></p><p><a href="https://www.bilibili.com/video/BV1t94y1z7NV/?vd_source=ccf90130d80396981859cd525be711f0">参考教程</a></p><p>闪电附身可以复制一个人物模型，然后略微放大直至包裹原人物模型，再给该模型贴上动态闪电贴图并打开alpha和add模式，选择合适的UV模式。然后打开e3d的自发光（输出→多通道混合器→自发光）和渲染辉光</p><p>模型人物边缘辉光可以用e3d的预设材质【physical→black_outline】，然后打开渲染辉光或用deep glow</p><h3 id="穿梭-鱼眼效果"><a href="#穿梭-鱼眼效果" class="headerlink" title="穿梭&#x2F;鱼眼效果"></a>穿梭&#x2F;鱼眼效果</h3><p>光学补偿效果</p><h3 id="线性光芒效果"><a href="#线性光芒效果" class="headerlink" title="线性光芒效果"></a>线性光芒效果</h3><p>方法1：Shine插件<br>方法2：镜头光晕&gt;分形杂色&gt;cc raidal blur</p><h3 id="故障转场"><a href="#故障转场" class="headerlink" title="故障转场"></a>故障转场</h3><p>1、故障置换图：分型杂色类型选择“块”，对比度和亮度拉高。缩放把宽度和高度拉高，拉成长方形。演化表达式time*2000。</p><p>复制这个分型杂色，调整对比度，把亮度改为负值。缩放把宽度再拉高，高度减小，拉成长条状。该分型杂色混合模式改为“颜色加深”</p><p>2、调整图层：使用“置换图”效果，选择刚才的故障置换图，选择“效果和蒙版”。调整“最大水平置换”和“最大水平置换”的关键帧。外加红蓝分离效果就完成了。</p><h3 id="白天变黑夜"><a href="#白天变黑夜" class="headerlink" title="白天变黑夜"></a>白天变黑夜</h3><p>场景最好没有明显的阴影。首先curve拉低亮度，再稍微拉低中灰部。tint选择一个合适的蓝色。colorma做一个黑白天空遮罩，用于替换天空。</p><p>colorma（色光）</p><p>参考：<br><a href="https://www.bilibili.com/video/BV1RN4y1M7xN/?vd_source=ccf90130d80396981859cd525be711f0">AE教程！直接从白天到黑夜的逼真转换！</a></p><h2 id="Ae变速"><a href="#Ae变速" class="headerlink" title="Ae变速"></a>Ae变速</h2><p>选择帧混合&#x2F;光流法后，直接使用Twixtor，给 <code>输出</code>的速度打关键帧就可以了。</p><h3 id="Twixtor补帧方法"><a href="#Twixtor补帧方法" class="headerlink" title="Twixtor补帧方法"></a>Twixtor补帧方法</h3><p>方法1（适合短镜头）：<br>把画面裁成多个小段，画面动了就裁一刀。然后把裁剪的片段全都缩成1帧时长，序列所有图层后预合成。在合成上使用twixtor，<code> 来源控制</code>中取消勾选  <code>在fps中输出fps </code>，并在下列 <code>帧速率</code>输入视频的帧数；<code>跟踪控制</code>中 <code>图像预处理</code>改为“对比度&#x2F;边缘增强”；<code>输出控制</code>中 <code>帧插值</code>改为“运动加权混合”，<code>扭曲</code>改为“向前”。再次预合成，打开时间重映射，将最后关键帧拉到片段末尾；找到片段的坏帧，在该处的时间重映射打关键帧，并将关键帧拉到末尾关键帧，就完成了。</p><p>方法2（适合长镜头）：</p><p>预合成片段，在合成上使用twixtor，<code> 来源控制</code>中取消勾选  <code>在fps中输出fps </code>，并在下列 <code>帧速率</code>输入“视频的帧数&#x2F;3”（这里的&#x2F;3指的是几帧画面动一次）；<code>跟踪控制</code>中 <code>图像预处理</code>改为“对比度&#x2F;边缘增强”；<code>输出控制</code>中 <code>帧插值</code>改为“运动加权混合”，<code>扭曲</code>改为“反转 扭曲&#x2F;智能混合”。</p><p>参考：<br><a href="https://www.bilibili.com/video/BV1CS4y1G7Cy/?vd_source=ccf90130d80396981859cd525be711f0">【AE教程】Twixtor补帧的两种方式</a></p><h2 id="插件效果合集"><a href="#插件效果合集" class="headerlink" title="插件效果合集"></a>插件效果合集</h2><p>twixtor补帧插件</p><h3 id="Saber辉光插件"><a href="#Saber辉光插件" class="headerlink" title="Saber辉光插件"></a>Saber辉光插件</h3><p>各种预设可选，主要利用蒙版路径来改变形状。可以调节开始和结束偏移调整运动轨迹，主体和辉光都可以调。</p><h3 id="震动插件"><a href="#震动插件" class="headerlink" title="震动插件"></a>震动插件</h3><p>twist<br>s_shake</p><h3 id="买量插件效果"><a href="#买量插件效果" class="headerlink" title="买量插件效果"></a>买量插件效果</h3><p>plexus插件，高科技连线<br>echospace插件，复制延迟。<br>动态拼贴，复制画面、补全边缘画面</p><h3 id="线条生长动画插件"><a href="#线条生长动画插件" class="headerlink" title="线条生长动画插件"></a>线条生长动画插件</h3><p>3d stroke</p><p><a href="http://www.bilibili.com/video/BV1gw411A7vN">www.bilibili.com/video/BV1gw411A7vN</a></p><h3 id="质感、粗糙度"><a href="#质感、粗糙度" class="headerlink" title="质感、粗糙度"></a>质感、粗糙度</h3><p>Noise</p><h3 id="锐化"><a href="#锐化" class="headerlink" title="锐化"></a>锐化</h3><p>最好用：universe.fin…</p><p>可调节：钝化蒙版</p><p>全部锐化：锐化</p><h3 id="图层高光、阴影"><a href="#图层高光、阴影" class="headerlink" title="图层高光、阴影"></a>图层高光、阴影</h3><p>shadow studio，具体参数参考：AE卡通栏目包装案例_让静态画面活过来GhostSY，9:30</p><h3 id="黑场去除"><a href="#黑场去除" class="headerlink" title="黑场去除"></a>黑场去除</h3><p>“提取”效果</p><p><a href="http://www.bilibili.com/video/BV1S1421C73F">www.bilibili.com/video/BV1S1421C73F</a></p><h2 id="粒子说明"><a href="#粒子说明" class="headerlink" title="粒子说明"></a>粒子说明</h2><p>sprite是始终朝向摄像机，多边形是可以看到片面的</p><h2 id="Ae技巧"><a href="#Ae技巧" class="headerlink" title="Ae技巧"></a>Ae技巧</h2><h3 id="图层自由变形"><a href="#图层自由变形" class="headerlink" title="图层自由变形"></a>图层自由变形</h3><p>贝塞尔曲线变形效果</p><h3 id="time永久循环"><a href="#time永久循环" class="headerlink" title="time永久循环"></a>time永久循环</h3><p>time*任意数值%32768<br>这个参数同样也可以修正分型杂色time后期变慢的问题<br>解释：模运算的结果是0到32767之间的循环数值。32768是2的15次方，可能涉及到16位有符号整数的围，或者某些内部计算使用这个数值作为上限。</p><h3 id="stardust制作线条生长动画"><a href="#stardust制作线条生长动画" class="headerlink" title="stardust制作线条生长动画"></a>stardust制作线条生长动画</h3><p><a href="http://www.bilibili.com/video/BV1HN411b7Rf">www.bilibili.com/video/BV1HN411b7Rf</a></p><h3 id="保留基础透明度"><a href="#保留基础透明度" class="headerlink" title="保留基础透明度"></a>保留基础透明度</h3><p>Ae 还提供了一种特殊的 Alpha 遮罩，称为“保留基础透明度”或“保持透明度”</p><h3 id="雨滴模型溅射思路"><a href="#雨滴模型溅射思路" class="headerlink" title="雨滴模型溅射思路"></a>雨滴模型溅射思路</h3><p>突然想到一种方法：e3d创建模型，然后particular发射水花粒子（粒子为水花动画贴图或别的方式）。使用灯光从顶部照射模型，照射到的地方就是雨水溅射的地方，可以使用阈值来增强溅射部分。</p><p><a href="https://www.bilibili.com/video/BV1gf42127oW">https://www.bilibili.com/video/BV1gf42127oW</a></p><h3 id="图层沿路径移动"><a href="#图层沿路径移动" class="headerlink" title="图层沿路径移动"></a>图层沿路径移动</h3><ol><li><strong>创建路径</strong> ：</li></ol><ul><li>使用钢笔工具（Pen Tool）在合成窗口中绘制一条路径。这条路径可以是直线、曲线或任意形状。</li></ul><ol start="2"><li><strong>复制路径</strong> ：</li></ol><ul><li>选择路径图层，然后按下 <code>U</code>键显示路径关键帧。</li><li>选择路径关键帧，按 <code>Ctrl+C</code>（Windows）或 <code>Cmd+C</code>（Mac）复制路径。</li></ul><ol start="3"><li><strong>应用路径到图层位置</strong> ：</li></ol><ul><li>选择要沿路径移动的图层。</li><li>按 <code>P</code>键显示位置属性。</li><li>确保时间指针在时间轴的起始位置，然后按 <code>Ctrl+V</code>（Windows）或 <code>Cmd+V</code>（Mac）粘贴路径。这会将路径关键帧粘贴到图层的位置属性上。</li></ul><ol start="4"><li><strong>调整动画</strong> ：</li></ol><ul><li>你可以通过调整关键帧的位置和时间来控制图层沿路径移动的速度和开始时间。</li><li>使用 <code>Easy Ease</code>或 <code>Graph Editor</code>可以让动画更加平滑。</li></ul><ol start="5"><li><strong>对齐和旋转</strong> （可选）：</li></ol><ul><li>如果你希望图层在移动过程中始终保持对齐路径方向，可以使用“自动定向”（Auto-Orient）功能。</li><li>选择图层，然后进入 <code>Layer</code> &gt; <code>Transform</code> &gt; <code>Auto-Orient...</code>，选择“沿路径定向”（Orient Along Path）。</li></ul><p>这样，你的图层就会沿着你绘制的路径进行移动了。如果需要更复杂的动画效果，可以结合使用其他动画属性和特效。</p><h2 id="Ae问题及解决方法"><a href="#Ae问题及解决方法" class="headerlink" title="Ae问题及解决方法"></a>Ae问题及解决方法</h2><h3 id="粒子重复"><a href="#粒子重复" class="headerlink" title="粒子重复"></a>粒子重复</h3><p>split clip - loop，有可能会产生全部一样的粒子</p><h3 id="变换缩放导致的崩溃"><a href="#变换缩放导致的崩溃" class="headerlink" title="变换缩放导致的崩溃"></a>变换缩放导致的崩溃</h3><p>使用“变换”效果的缩放功能，如果放大过大会导致显存不足等方式而崩溃。所以最好使用原先的缩放功能</p><h3 id="图层效果后使用效果"><a href="#图层效果后使用效果" class="headerlink" title="图层效果后使用效果"></a>图层效果后使用效果</h3><p>由于图层效果是在所有效果之后才生效，因此可以在该图层前建立一个调整图层来用想要的效果。<br>（例如图层描边效果使用deep glow）<br><a href="https://www.bilibili.com/video/BV1FT421U7yu">https://www.bilibili.com/video/BV1FT421U7yu</a></p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ae </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pr笔记</title>
      <link href="/2022/06/26/Pr%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/26/Pr%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>1、 剃刀工具–就是我们常说的的剪切素材工具，用它可以剪切任何素材。可以用Ctrl＋K来剪切素材，亦可以用C来剪切，还可以拖动素材的边缘进行剪切；三个方法，非常好用。</p><p>2、 波纹剪切–就是在剪切音视频素材后，后续的素材会自动移动到前面去，而使时间线上不留下空隙。可以用键盘上的Q、W来实现快速波纹剪切,在素材被选中的情况下，按Q默认删除时间线指针前面的素材，按W自动删除指正后面的素材。</p><p>3、 如果在删除素材后留下空隙，我们也可以选中空隙处，点Delete即可。</p><p>4、 在需要大量【转场】效果的时候，可以用Ctrl+D，选中所要添加转场的所有素材，按下Ctrl＋D为视频素材添加默认转场；按下Ctrl＋Shift＋D为音频素材添加默认转场；Shift + D则为素材添加默认音视频转场。</p><p>5、 J、K、L的运用，L为加速播放，连续按L会加速播放，K为暂停键，J为后退键；在我们观看素材的时候，非常实用。</p><p>6、 按住alt键不放，在时间轴上就可以单独选中音频或者视频。也可以选中素材，右键选择取消链接，也可将音视频分开。</p><p>7、 选中素材，然后按住Ctrl键不放，可以将任意素材添加到中间位置。</p><p>8、 键盘上的\，为显示目前素材的比例符合界面的宽度，+ -为缩放素材的显示比例。</p><p>9、 在删除多个视频片段时，我们可以按Shift键，然后选择要删除的素材，之后所有素材就会自动向前吸合，不会出现空隙。</p><p>10、 导入、保存和导出：Ctrl+I可以一键导入剪辑素材；Ctrl+S为保存素材，经常Ctrl+S一下能够帮助你避免死机和软件崩掉产生的影响；Ctrl+M是一键导出视频，非常方便。</p><p>9、在选取素材最后端的时候，可以按住Shift键，拉杆就可以自动吸附到素材后面。</p><p>10、Ctrl+Alt同时按住，可以把前后剪切的素材互换位置。</p><p>11、双击素材后，在素材预览界面，使用I和O来进行标记，即I和O之间的素材为标记好的，然后点击键盘上的，（逗号）即可插入标记的素材。</p><p>12、快速选中后面素材：按D键就可以选中后面的素材了。</p><p>13、按住Shift键，可以选中多个素材。</p><p>14、按住Alt键，然后拖动素材，可以复制素材。</p><p>15、复制素材效果关键帧，Ctrl+C为选中复制，Ctrl+Alt+V为将选中素材效果复制到另一个素材上，这个方法在我们日常日常操作上非常的使用。</p><p>16、Alt+滚轮，可以缩放时间线，也是非常方便的。</p><p>17、封闭间隙的使用，在我们日常的剪辑过程中，一个素材会产生很多个间隙，这时候我就就可以在工具栏中，点序列下的封闭间隙，这样所有间隙就没有了，这个方法也是非常使用的。</p><p>18、我们在导出视频的时候可以选择H264，这个是非常小和清晰的mp4格式的视频。</p><p>19、V键，这是我们选择快捷键，使用非常方便。</p><p><a href="https://zhuanlan.zhihu.com/p/346203647">参考文章</a></p><h2 id="保存预设"><a href="#保存预设" class="headerlink" title="保存预设"></a>保存预设</h2><p>选择要保存的效果，右键选择保存预设</p><h2 id="调整音效"><a href="#调整音效" class="headerlink" title="调整音效"></a>调整音效</h2><p>调整音效可以给音频添加参数均衡器效果，根据频道适当调整。</p><h2 id="黑白保留单色"><a href="#黑白保留单色" class="headerlink" title="黑白保留单色"></a>黑白保留单色</h2><p>Pr也可以做黑白保留单色（如黑白画面然后保留红色），在Pr中找“保留颜色”效果。然后选择要保留的颜色，脱色量改到100%，匹配颜色改为“使用色相”，最后调整容差。</p><h2 id="柔光特效"><a href="#柔光特效" class="headerlink" title="柔光特效"></a>柔光特效</h2><p>打一个关键帧，亮度-50，对比度+50，饱和度-50，光感+50，高光+50。再打个关键帧调回正常0。多重复这两个关键帧，再加个黑白效果。</p><h2 id="Au无限延长bgm"><a href="#Au无限延长bgm" class="headerlink" title="Au无限延长bgm"></a>Au无限延长bgm</h2><p>适合没有歌词的bgm，从Pr右键音频选择在Au中编辑，在Au中需要将音频生成到一个多轨项目中，左上角点击“”多轨”，选择一个保存的位置。创建好后，把音频拖入到轨道，找到“属性”一栏中的重新混合，启动并完成后，就可以选择音频的长度，延长后保存即可。</p><p><a href="https://www.bilibili.com/video/BV1Jb411B7qm/">参考视频</a></p><h2 id="描边弹出动画"><a href="#描边弹出动画" class="headerlink" title="描边弹出动画"></a>描边弹出动画</h2><p>复制裁剪要做效果的片段，先用查找边缘效果，选择反转。添加颜色校正的“色彩”效果，然后把片段不透明度“混合模式”改成线性减淡之类的。添加变换效果，把描边放大到大概180，关键帧渐入渐出。调整关键帧曲线先快后慢，大致如下。</p><p><img src="/../images/post/Pr%E7%AC%94%E8%AE%B0/1671018928105.png" alt="1671018928105"></p><p>调整透明度渐入渐出，另外可以用色彩效果调整描边。可以多复制几次错位做效果</p><h2 id="视频变速音频不变"><a href="#视频变速音频不变" class="headerlink" title="视频变速音频不变"></a>视频变速音频不变</h2><p>视频变速时，不要勾选保持音调不变。音频添加“音高换挡器”效果，点击该效果的编辑，改变比率：比如变速为120%，那么比率为1&#x2F;1.2，即0.8333…，精度选最高，音高设置勾选“使用相应的默认设置”。音调变回来了，但左右声道大小不一，再给音频添加“用左侧填充右侧”效果，但如果是环绕声则不要添加。</p><h2 id="声音变磁性"><a href="#声音变磁性" class="headerlink" title="声音变磁性"></a>声音变磁性</h2><p>选择“人声增强”效果，选择性别后就可以了。</p><h2 id="绿幕抠像"><a href="#绿幕抠像" class="headerlink" title="绿幕抠像"></a>绿幕抠像</h2><p>常用效果：</p><p>超级键（最好用）、非红色键（还不错）、颜色键（一般）</p><p>goodbyegreenscreen插件：加载太慢了</p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在linux开服cs2d</title>
      <link href="/2022/06/26/cs2d%E5%9C%A8linux%E5%BC%80%E6%9C%8D/"/>
      <url>/2022/06/26/cs2d%E5%9C%A8linux%E5%BC%80%E6%9C%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h2><p>ls: 列出目录内容cd：切换目录pwd：显示当前的目录路径rm：删除目录mv：移动文件或目录，或者重命名cp: 复制文件或目录rm: 移除文件或目录这里列举一些基本命令，详细内容可以搜索Linux教程了解相关命令。</p><h2 id="开服前的准备"><a href="#开服前的准备" class="headerlink" title="开服前的准备"></a>开服前的准备</h2><p>不建议用root用户建服，最好再新建一个用户用来开服。新用户使用过程中可能会遇到用户权限的问题，需要通过chown或chmod命令赋予用户权限。ssh连接服务器命令：ssh 用户名@服务器公网IP，即可远程连接你的Linux主机。<br> 在开服之前需要下载CS2D本体+CS2D托管服务端(Dedicated server)。注意是下载Linux版本：<a href="https://cs2d.com/download.php1%E3%80%81Client%EF%BC%9A2%E3%80%81Server%EF%BC%9A">https://cs2d.com/download.php1、Client：2、Server：</a><br> 可以选择直接在服务器下载解压，也可以本地下载解压再通过ssh、ftp或其他方式进行传输(ftp需要另外安装搭建)。下载下来是两个zip文件，在服务器上解压的方式是 “unzip 文件名称”。<br> 64位服务器问题：64位服务器无法运行32位的cs2d_dedicated，还需要32位运行库，安装ia32-libs。</p><h2 id="如何开服及托管"><a href="#如何开服及托管" class="headerlink" title="如何开服及托管"></a>如何开服及托管</h2><p>接下来就是开服环节了，运行方法很简单，只需要输入.&#x2F;cs2d_delicated，就可以愉快玩耍了。注意开放服务器相应的UDP端口，否则在游戏中可能找不到你的服务器。但如果你想要关闭终端后仍然托管运行，那么需要以下方法之一：</p><p>方法一：nohup .&#x2F;cs2d_dedicated&amp;，&amp;是后台运行方法二：安装screen，输入命令yum install  screen这里推荐方法二，screen不仅可以后台托管，多开服务器，也能随时查看状态，方便管理。输入screen -S 任意名称(如cs2d) 进入子界面，再输入.&#x2F;cs2d_delicated即可开服。<br> 查看开服是否成功：在CS2D官网服务器清单查看是否有自己开设的服务器：<a href="http://www.cs2d.com/servers.php%E6%8E%A5%E4%B8%8B%E6%9D%A5%E8%BF%9B%E5%85%A5CS2D%EF%BC%8C%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%85%A5IP%E8%BF%9B%E5%85%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82">http://www.cs2d.com/servers.php接下来进入CS2D，在服务器列表查找，也可以输入IP进入服务器。</a></p><h2 id="添加模组问题"><a href="#添加模组问题" class="headerlink" title="添加模组问题"></a>添加模组问题</h2><p>需要注意的是，Linux系统默认不覆盖文件夹，而是直接替换旧项目(原文件会被删除)。在安装模组&#x2F;贴图&#x2F;音效&#x2F;脚本时，如果不了解覆盖方法，覆盖前不放心，可以考虑备份一份原文件。</p><h2 id="脚本开发管理"><a href="#脚本开发管理" class="headerlink" title="脚本开发管理"></a>脚本开发管理</h2><p>想要在服务器里修改文本参数，可以用vi(或者vim)  文件名称，此时可以查看文本内容，按i进行编辑，编辑完毕后”esc”退出编辑状态，再按”:”，输入wq!保存退出。另外推荐使用vscode的远程开发，下载vscode，安装remote-ssh插件，就可以在本地直接远程编写服务器上的脚本，能获得更好的开发体验。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs2d </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
